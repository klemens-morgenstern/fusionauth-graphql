"A string that is always formatted as a UUID"
scalar UUID
"A string representing a data"
scalar Date
"A string that is always JSON"
scalar JSON


"""FusionAuth accepts and returns Locales on the API using the Java standard format of a ISO 639-1 two letter language code followed by an optional underscore and a ISO 3166-1 alpha-2 country code. Below is a table of common language and country codes and the resulting locale string that can either be sent into an API or be expected on the API response. This is not an exhaustive list but only provided as an example."""
enum Locale {
    "Arabic"         AR,
    "Danish"         DA,
    "German"         DE,
    "English"        EN,
    "Spanish"        ES,
    "Spanish Mexico" ES_MX,
    "Finish"         FI,
    "French"         FR,
    "Italian"        IT,
    "Japanese"       JA,
    "Korean"         KO,
    "Dutch"          NL,
    "Norwegian"      NO,
    "Polish"         PL,
    "Portuguese"     PT,
    "Russian"        RU,
    "Swedish"        SV,
    "Chinese Taiwan" ZH_TW,
    "Chinese China"  ZH_CN,
}

"Time zones in an IANA time zone format."
scalar Timezone

"A location in a connection that can be used for resuming pagination."
scalar Cursor

type Error {
    "The code of the error message."
    code: String!
    "A descriptive error message that details the problem that occurred."
    message: String!
}

type Errors {
    "The list of general error messages."
    generalErrors: [Error!]

    "The list of field error message."
    fieldErrors: [Error!]
}


"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: Cursor
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: Cursor
}

"Encryption schemes, see [here](https://fusionauth.io/docs/v1/tech/reference/password-encryptors)"
enum EncryptionScheme {
    SALTED_MD5,
    SALTED_SHA256,
    SALTED_HMAC_SHA256,
    SALTED_PBKDF2_HMAC_SHA256,
    BCRYPT
}
enum TwoFactorDelivery {NONE, TEXT_MESSAGE}
enum UsernameStatus { ACTIVE, PENDING, REJECTED }

input UserInput {
    "An ISO-8601 formatted date of the User’s birthdate such as YYYY-MM-DD."
    birthDate: Date
    "An object that can hold any information about a User that should be persisted."
    data: JSON
    """The User’s email address. A email address is a unique in FusionAuth and stored in lower case.

    If email is not provided, then the username will be required."""
    email: String
    """The method for encrypting the User’s password. The following encryptors are provided with FusionAuth:

     * [salted-md5](https://fusionauth.io/docs/v1/tech/reference/password-encryptors#salted-md5)
     * [salted-sha256](https://fusionauth.io/docs/v1/tech/reference/password-encryptors#salted-sha-256)
     * [salted-hmac-sha256](https://fusionauth.io/docs/v1/tech/reference/password-encryptors#salted-hmac-sha-256)
     * [salted-pbkdf2-hmac-sha256](https://fusionauth.io/docs/v1/tech/reference/password-encryptors#salted-pbkdf2-hmac-sha-256)
     * [bcrypt](https://fusionauth.io/docs/v1/tech/reference/password-encryptors#salted-bcrypt)

    You can also create your own password encryptor. See the Password Encryptors section for more information."""
    encryptionScheme: EncryptionScheme
    "The expiration instant of the User’s account. An expired user is not permitted to login."
    expiry: Int
    "The factor used by the password encryption scheme. If not provided, the `PasswordEncryptor` provides a default value. Generally this will be used as an iteration count to generate the hash. The actual use of this value is up to the `PasswordEncryptor` implementation."
    factor: String
    "The first name of the User."
    firstName: String
    "The User’s full name as a separate field that is not calculated from firstName and lastName."
    fullname: String
    "The URL that points to an image file that is the User’s profile image."
    imageUrl: String
    "The User’s last name."
    lastName: String
    "The User’s middle name."
    middleName: String
    "The User’s mobile phone number. This is useful is you will be sending push notifications or SMS messages to the User."
    mobilePhone: String
    """The email address of the user’s parent or guardian. This field is used to allow a child user to identify their parent so FusionAuth can make a request to the parent to confirm the parent relationship.

    Family configuration must be enabled in the tenant Family configuration and the corresponding family email templates must be configured for FusionAuth to notify the parent during user creation."""
    parentEmail: String
    """The User’s plain texts password. This password will be hashed and the provided value will never be stored and cannot be retrieved.

    This field is optional only if `sendSetPasswordEmail` is set to `true`. By default `sendSetPasswordEmail` is `false`, and then this field will be required."""
    password: String
    "Indicates that the User’s password needs to be changed during their next login attempt."
    passwordChangeRequired: Boolean
    "An array of locale strings that give, in order, the User’s preferred languages. These are important for email templates and other localizable text. See [Locales](https://fusionauth.io/docs/v1/tech/reference/data-types#locales)."
    preferredLanguages:  [Locale!]

    "(Only used when importing) The User’s password salt. Required if encryptionScheme is provided. Empty string is allowed."
    salt: String!

    """The User’s preferred timezone. The string must be in an [IANA](https://www.iana.org/time-zones) time zone format. For example:

    ```
    America/Denver or US/Mountain
    ```
    """
    timezone: Timezone
    """The User’s preferred delivery for verification codes during a two factor login request.
    The possible values are:
      * None
      * TextMessage

    When using TextMessage the User will also need a valid mobilePhone.
    """
    twoFactorDelivery : TwoFactorDelivery
    "Determines if the User has two factor authentication enabled for their account or not."
    twoFactorEnabled: Boolean
    """The Base64 encoded secret used to generate Two Factor verification codes.

    You may optionally use value provided in the secret field returned by the Two Factor Secret API instead of generating this value yourself.

    Unless you are using TextMessage as your delivery type, ensure you are able to share the secret with the User before enabling Two Factor authentication. Beginning in version 1.17.0, if you do create a User with TextMessage set as the twoFactorDelivery type and you omit this value, the secret will be generated for you. The secret can be generated because it is not necessary to share the secret with the User for this delivery method.

    When using None as the twoFactorDelivery this value will be required."""
    twoFactorSecret: String
    """The username of the User. The username is stored and returned as a case sensitive value, however a username is considered unique regardless of the case. bob is considered equal to BoB so either version of this username can be used whenever providing it as input to an API.

    If username is not provided, then the email will be required."""
    username: String
    """The current status of the username. This is used if you are moderating usernames via CleanSpeak. The possible values are:

      * `ACTIVE` - the username is active
      * `PENDING` - the username is pending approval/moderation
      * `REJECTED` - the username was rejected during moderation

    This state is managed by CleanSpeak, it may be changed by setting it on this request."""
    usernameStatus: UsernameStatus
}

type TokenPair {
    provider: String!
    token: String!
}

type UserMemberShip {
    "An object that can hold any information about the User for this membership that should be persisted."
    data: JSON
    "The Id of the Group of this membership."
    groupId: UUID
    "The unique Id of this membership."
    id: UUID
    "The instant that the membership was created."
    insertInstant: Int

    group: Group
}

type UserRegistration {
    "The Id of the Application that this registration is for."
    applicationId: UUID!
    "The Authentication Token for this registration (if one exists)."
    authenticationToken: String

    "This Id is used by FusionAuth when the User’s username for this registration is sent to CleanSpeak to be moderated (filtered and potentially sent to the approval queue). It is the content Id of the username inside CleanSpeak."
    cleanSpeakId: UUID
    "An object that can hold any information about the User for this registration that should be persisted."
    data: JSON
    "The Id of this registration."
    id: UUID!
    "The instant that this registration was created."
    insertInstant: Int!
    "The instant that the User last logged into the Application for this registration."
    lastLoginInstant: Int!
    "An array of locale strings that give, in order, the User’s preferred languages for this registration. These are important for email templates and other localizable text."
    preferredLanguages: [Locale!]!
    "The list of roles that the User has for this registration."
    roleNames : [String!]
    roles: [Role!]!

    "The User’s preferred timezone for this registration. The string will be in an IANA time zone format."
    timezone: Timezone!
    """A map that contains tokens returned from identity providers.

    For example, if this user has authenticated using the Facebook Identity Provider, the Facebook access token will be available in this map, keyed by name Facebook. For an OpenID Connect Identity provider, or other generic providers, if a token is stored it will be keyed by the Identity Provider unique Id."""
    tokens: [TokenPair!]
    "The username of the User for this registration only."
    username: String!
    """The current status of the username. This is used if you are moderating usernames via CleanSpeak. The possible values are:

      * `ACTIVE` - the username is active
      * `PENDING` - the username is pending approval/moderation
      * `REJECTED` - the username was rejected during moderation

    If a username has been rejected, it is still possible to allow the User to update it and have the new one moderated again."""
    usernameStatus: UsernameStatus!
    "This value indicates if this User’s registration has been verified."
    verified: Boolean

    application: Application

}

type User {
    "True if the User is active. False if the User has been deactivated. Deactivated Users will not be able to login."
    active: Boolean!
    "The User’s birthdate formatted as YYYY-MM-DD"
    birthDate: Date!
    "This Id is used by FusionAuth when the User’s username is sent to CleanSpeak to be moderated (filtered and potentially sent to the approval queue). It is the content Id of the username inside CleanSpeak."
    cleanSpeakId: UUID

    "An object that can hold any information about the User that should be persisted."
    data: JSON!
    "The User’s email address."
    email: String!
    "The expiration instant of the User’s account. An expired user is not permitted to login."
    expiry: Int!

    "The first name of the User."
    firstName: String!
    "The User’s full name as a separate field that is not calculated from firstName and lastName."
    fullname: String!
    "The User’s unique Id."
    id: UUID!
    "The URL that points to an image file that is the User’s profile image."
    imageUrl: String!
    "The instant when user was created."
    insertInstant: Int!
    "The instant when the User logged in last."
    lastLoginInstant: Int!
    "The User’s last name."
    lastName: String!
    "The list of memberships for the User."
    memberships: [UserMemberShip!]
    "The User’s middle name."
    middleName: String!
    "The User’s mobile phone number. This is useful is you will be sending push notifications or SMS messages to the User."
    mobilePhone: String!
    "The email address of the user’s parent or guardian. If this value was provided during a create or update operation, this value value will only remain until the child is claimed by a parent."
    parentEmail: String!
    "Indicates that the User’s password needs to be changed during their next login attempt."
    passwordChangeRequired: Boolean!
    "The instant that the User last changed their password."
    passwordLastUpdateInstant: Int!
    "An array of locale strings that give, in order, the User’s preferred languages. These are important for email templates and other localizable text."
    preferredLanguages:  [Locale!]!
    "The list of registrations for the User."
    registrations: [UserRegistration!]
    "The Id of the Tenant that this User belongs to."
    tenantId: UUID!

    tenant: Tenant
    "The User’s preferred timezone. This can be used as a default to display instants, and it is recommended that you allow User’s to change this per-session. The string will be in an IANA time zone format."
    timezone: Timezone!
    """The User’s preferred delivery for verification codes during a two factor login request.
    The possible values are:

       * None
       * TextMessage
    """
    twoFactorDelivery : TwoFactorDelivery!
    "Determines if the User has two factor authentication enabled for their account or not."
    twoFactorEnabled: Boolean!
    "The username of the User."
    username: String!
    """The current status of the username. This is used if you are moderating usernames via CleanSpeak. The possible values are:

      * `ACTIVE` - the username is active
      * `PENDING` - the username is pending approval/moderation
      * `REJECTED` - the username was rejected during moderation

    If a username has been rejected, it is still possible to allow the User to update it and have the new one moderated again."""
    usernameStatus: UsernameStatus!
    "Whether or not the User’s email has been verified."
    verified: Boolean!
}

type UserResponse{
    "The access token, this string is an encoded JSON Web Token (JWT)."
    token: String!
    user: User!
}

type UserDeletionResponse {
    "Whether the request was a dry run or the requested action was applied."
    dryRun: Boolean!

    "Whether the requested action was deactivation or permanent deletion."
    hardDelete: Boolean!

    "The count of affected Users."
    total: Int!

    "The list of affected User Ids. This field is omitted from the response when no users were affected by the request."
    userIds: [UUID!]!
    users(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int): UsersConnection
}

input ImportUsersInput {

    """The encryption scheme used to encrypt plaintext passwords encountered in the request. If this value is omitted the system configured value will be used.

    The following encryptors are provided with FusionAuth:

    * [salted-md5](https://fusionauth.io/docs/v1/tech/reference/password-encryptors#salted-md5)
    * [salted-sha256](https://fusionauth.io/docs/v1/tech/reference/password-encryptors#salted-sha-256)
    * [salted-hmac-sha256](https://fusionauth.io/docs/v1/tech/reference/password-encryptors#salted-hmac-sha-256)
    * [salted-pbkdf2-hmac-sha256](https://fusionauth.io/docs/v1/tech/reference/password-encryptors#salted-pbkdf2-hmac-sha-256)
    * [bcrypt](https://fusionauth.io/docs/v1/tech/reference/password-encryptors#salted-bcrypt)
    """
    encryptionScheme: EncryptionScheme

    "The factor used to encrypt plaintext passwords encountered in the request. If this value is omitted the system configured value will be used."
    factor: Int

    "The list of Users to import."
    users : [UserInput!]!
}

enum SortFieldMissing {
    "When the field is not defined sort this record first." FIRST,
    "When the field is not defined sort this record last." LAST
}

enum Order {
    ASCENDING, DESCENDING
}

input SortField {
    "The value to substitute if this field is not defined. Two special values may be used:"
    missing: SortFieldMissing
    """The name of the field to sort.

    Due to how the search index is structured not all fields on the user are sortable. The following field names are supported.

     * `birthDate`
     * `email`
     * `fullName`
     * `id`
     * `insertInstant`
     * `lastLoginInstant`
     * `login`
     * `registrations.applicationId`
     * `registrations.id`
     * `registrations.insertInstant`
     * `registrations.lastLoginInstant`
     * `registrations.roles`
     * `tenantId`
     * `username`
    """
    name: String!
    "The order to sort the specified field. Defaults to ASCENDING"
    order: Order
}


"A `Login` edge in the connection."
type UsersEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Login` at the end of the edge."
    node: User
}

"A connection to a list of `Login` values."
type UsersConnection {
    "A list of edges which contains the `Information` and cursor to aid in pagination."
    edges: [UsersEdge!]!
    "A list of `User` objects."
    nodes: [User]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `User` you could get from the connection."
    totalCount: Int!
}


type Login {
    "The unique Id of the application that is represented by this login record."
    applicationId: UUID
    "The name of the application at the time this record was created."
    applicationName: String!
    application: Application

    "The instant this login occurred."
    instant: Int!

    "The IP address if provided during the login request."
    ipAddress: String!

    "The User’s email address or username at the time of the login request."
    loginId: String!

    "The unique Id of the user that is represented by this login record."
    userId:  UUID!
    user: User

}

"A `Login` edge in the connection."
type LoginsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Login` at the end of the edge."
    node: Login
}

"A connection to a list of `Login` values."
type LoginsConnection {
    "A list of edges which contains the `Information` and cursor to aid in pagination."
    edges: [LoginsEdge!]!
    "A list of `Information` objects."
    nodes: [Login!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Login` you could get from the connection."
    totalCount: Int!
}

type Query {
    "Retrieve a User using a JWT"
    currentUser : UserResponse
    "Retrieve a User by Id"
    user("The unique Id of the User to retrieve." id: UUID!) : UserResponse
    "Retrieve a User by login Id"
    userByLogin("The unique Id of the User to retrieve. The loginId can be either the email or username." login: String!) : UserResponse
    "Retrieve a User by username"
    userByEMail("The email of the User to retrieve." email: String!) : UserResponse
    "Retrieve a User by username"
    userByUsername("The username of the User to retrieve." username: String!) : UserResponse
    "Retrieve a User by Change Password Id"
    userByChangePasswordId(
        "The change password Id associated with the user when the Forgot Password workflow has been started"
        changePasswordId: String!) : UserResponse
    "Retrieve a User by Email Verification Id"
    userByVerificationId(
        "The verification Id associated with the user when the Email verification process has been started."
        verificationId: String!) : UserResponse
    "Search for Users by Id"
    searchUsers(
        "An array of User Ids to delete. The userIds, query, and queryString parameters are mutually exclusive, they are listed here in order of precedence."
        userIds: [UUID!],
        """The raw JSON Elasticsearch query that is used to search for Users. The userIds, query, and queryString parameters are mutually exclusive, they are listed here in order of precedence.

        It is necessary to use the query parameter when querying against registrations in order to achieve expected results, as this field is defined as a nested datatype in the Elasticsearch mapping."""
        query: JSON,
        """The Elasticsearch query string that is used to search for Users to be deleted. The userIds, query, and queryString parameters are mutually exclusive, they are listed here in order of precedence."""
        queryString: JSON,
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "The number of search results to return. Used for pagination."
        last: Int,
        "The start row within the search results to return. Used for pagination."
        offset: Int,
        "An array of sort fields used to sort the result. The order the sort fields are provided will be maintained in the sorted output."
        sortFields: [SortField!]
        ) : UsersConnection!
    "Retrieve recent logins"
    recentLogins(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Defaults to 10. This parameter indicates the maximum amount of logins to return for a single request."
        last: Int,
        "Defaults to 0. This parameter provides the offset into the result set. Generally speaking if you wish to paginate the results, you will increment this parameter on subsequent API request by the size of the limit parameter."
        offset: Int,
        "This parameter will narrow the results to only logins for a particular user. When this parameter is omitted, the most recent logins for all of FusionAuth will be returned."
        userId: UUID
    ) : LoginsConnection!
}

extend type User {
    "Retrieve recent logins"
    recentLogins(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Defaults to 10. This parameter indicates the maximum amount of logins to return for a single request."
        last: Int,
        "Defaults to 0. This parameter provides the offset into the result set. Generally speaking if you wish to paginate the results, you will increment this parameter on subsequent API request by the size of the limit parameter."
        offset: Int) : LoginsConnection!
}


type Mutation {
    createUser(
        "The Id to use for the new User. If not specified a secure random UUID will be generated."
        userId:UUID,
        """Indicates to FusionAuth to send the User an email asking them to set their password. The Email Template that is used is configured in the System Configuration setting for **Set Password Email Template**.

        If you set this value to `true` the `password` field is then ignored, FusionAuth will set the initial password to a securely generated random string.

        If you have also enabled email verification and do not select to skip verification using the skipVerification parameter, only the setup password email will be sent to the user. Setting up the password using the email sent during this user create operation will implicitly verify the User’s email if it is not already verified.

        If the SMTP email configuration is not complete, or disabled, this value is ignored."""
        sendSetPasswordEmail: Boolean
        "Indicates to FusionAuth that it should skip email verification even if it is enabled. This is useful for creating admin or internal User accounts."
        skipVerification: Boolean
        "The payload with the user details"
        user: UserInput) : UserResponse!
    updateUser(
        "The Id of the User to update."
        userId:UUID!
        "Indicates to FusionAuth that it should skip email verification even if it is enabled. This is useful for creating admin or internal User accounts."
        skipVerification: Boolean
        "The payload with the user details"
        user: UserInput) : UserResponse!

    "Delete Users. Note the exactly one of the parameters userIds, quer and queryString must be passd."
    deleteUsers(
        "An array of User Ids to delete. The userIds, query, and queryString parameters are mutually exclusive, they are listed here in order of precedence."
        userIds: UUID!,
        """The raw JSON Elasticsearch query that is used to search for Users. The userIds, query, and queryString parameters are mutually exclusive, they are listed here in order of precedence.

It is necessary to use the query parameter when querying against registrations in order to achieve expected results, as this field is defined as a nested datatype in the Elasticsearch mapping."""
        query: JSON!,
        """The Elasticsearch query string that is used to search for Users to be deleted. The userIds, query, and queryString parameters are mutually exclusive, they are listed here in order of precedence."""
        queryString: JSON!,
        "Defaults to false. To preview the user Ids to be deleted by the request without applying the requested action set this value to true."
        dryRun: Boolean,
        "Defaults to false. To Permanently delete a user from FusionAuth set this value to true. Once a user has been permanently deleted, the action cannot be undone. When this value is set to false the user is marked as inactive and the user will be unable log into FusionAuth. This action may be undone by reactivating the user."
        hardDelete: Boolean) : UserDeletionResponse!

    "Reactivate the User"
    reactivateUser("The Id of the User to reactivate." userId: UUID!) : UserResponse

    "Import Multiple Users"
    importUsers(users: ImportUsersInput!) : Boolean

    " Verifies the User’s email address using the verificationId."
    verifyEmail(
        "The verification Id generated by FusionAuth used to verify the User’s account is valid by ensuring they have access to the provided email address."
        verificationId: String!) : Boolean

    "Resent verification email"
    resentVerificationEmail("The email address used to uniquely identify the User." email: String!,
        "If you would only like to generate a new verificationId and return it in the JSON body without FusionAuth attempting to send the User an email set this optional parameter to false."
        sendVerifyEmail: Boolean
        ) : String

    "Start the forgot password workflow using an API key"
    forgotPassword(
        "The login identifier of the user. The login identifier can be either the email or the username. The username is not case sensitive."
        loginId: String!,
        """The optional change password Id to be used on the Change a User’s Password API.

        It is recommended to omit this parameter and allow FusionAuth to generate the identifier. Use this parameter only if you must supply your own value for integration into existing systems."""
        changePasswordId: String,
        "Whether or not calling this API should attempt to send the user an email using the Forgot Password Email Template. Setting this to false will skip the email attempt and only set the changePasswordId for the user."
        sendForgotPasswordEmail: String) : String

    "This usage is generally intended to be part of an email workflow and does not require authentication. The changePasswordId used on this API request will have been previously generated by the Start Forgot Password API or by using the Forgot Password workflow on the FusionAuth login page."
    changePassword(
        """The changePasswordId that is used to identity the user after the Start Forgot Password workflow has been initiated.

        If this changePasswordId was sent via an email to the User by FusionAuth during User create in order to set up a new password, or as part of a Forgot Password request, then successful use of this identifier to change the User’s password will implicitly complete Email Verification if not already verified"""
        changePasswordId: String,
        """The login identifier of the user. The login identifier can be either the email or the username. The username is not case sensitive.

        When this value is provided it should be in place of the changePasswordId request parameter. If both the changePasswordId and loginId are provided on the request, the changePasswordId will take precedence."""
        loginId: UUID,
        "The User’s current password. When this parameter is provided the current password will be verified to be correct."
        currentPassword: String,
        "The User’s new password." password: String!) : String

    "This API is used to issue a flush request to the FusionAuth Search. This will cause any cached data to be written to disk. In practice it is unlikely you’ll find a need for this API in production unless you are performing search requests immediately following an operation that modifies the index and expecting to see the results immediately."
    flushSearchEngine: Boolean
}

input ActionInput {
    "The Id of the User that is being actioned."
    actioneeUserId: UUID!

    "The Id of the User that is taking the action on the User."
    actionerUserId: UUID!

    "The list of Application ids that the action is being performed in."
    applicationIds: [UUID!]

    "The comment left by the actioner."
    comment: String

    " Defaults to false. Whether FusionAuth should send an email to the User."
    emailUser: Boolean

    """The expiration instant of this User Action. This value is required for time-based User Actions.
    To cause the action to be applied indefinitely, or until the action is canceled or modified, set this value to 9223372036854775807."""
    expiry: Int


    "Defaults to false. The notifyUser flag that is passed along in any events FusionAuth sends to registered Webhooks."
    notifyUser: Boolean

    "The User Action Option that the actioner selected."
    option: String

    "The Id of the User Action Reason that the actioner selected."
    reasonId: UUID

    "The Id of the User Action that the actioner is performing on the User."
    userActionId: UUID!
}

type ActionHistory {
    "The Id of the User that took the modified (or created) the User Action."
    actionerUserId: UUID!

    user: User

    "An optional comment provided when the Action was created, updated or canceled."
    comment: String

    "The instant that this historical modification or creation was performed."
    createInstant: Int

    "The instant that the User Action expired at previously."
    expiry: Int

}

type Action {
    "The Id of the User that was actioned."
    actioneeUserId: UUID!
    actioneeUser: User

    "The Id of the User that took the action on the User. If the action was initiated by FusionAuth this value will not be provided."
    actionerUserId: UUID!
    actionerUser: User

    "This parameter if provided specifies the scope of the User  When an Action is scoped to one or more Applications the Application Ids will be provided in this parameter."
    applicationIds: [UUID!]

    "An optional comment provided when the Action was created, updated or canceled. This value will always be the last comment set on the action, see history for previous values."
    comment: String

    "The instant that the User Action was taken."
    createInstant: Int!

    "Whether FusionAuth will email the User when a time-based User Actions expires."
    emailUserOnEnd: Boolean!

    "Whether FusionAuth will send events when a time-based User Actions expires."
    endEventSent: Boolean!

    "The expiration instant of the User "
    expiry: Int

    "The Id of the User Action record."
    id: UUID!

    "The historical data for the User Action Log. Each time the User Action is modified or when the User Action is canceled a new historyItem is recorded."
    history: [ActionHistory!]

    "The localized version of the User Action Option that was selected by the actioner."
    localizedOption: String

    "The localized version of the User Action Reason that was selected by the actioner."
    localizedReason: String

    "Whether or not FusionAuth will send events to registered Webhooks when a time-based User Action expires."
    notifyUserOnEnd: String!

    "The non-localized version of the User Action Option that was selected by the actioner."
    option: String

    "The non-localized version of the User Action Reason that was selected by the actioner."
    reason: String

    "The User Action Reason code that was selected by the actioner."
    reasonCode: String

    "The unique Id of the User Action This Id can be used to retrieve the User Action using the Retrieve a User Action API."
    userActionId: UUID!
    userAction: UserAction
}

input UpdateAction {
    "The Id of the User that is taking the action on the User."
    actionerUserId : UUID!

    "The comment left by the actioner."
    comment : String

    "Defaults to false. Whether FusionAuth should send an email to the User."
    emailUser: Boolean

    "The expiration instant of this User Action. This is required for time-based User Actions."
    expiry: Int

    "Defaults to false.     The notifyUser flag that is passed along in any events FusionAuth sends to registered Webhooks."
    notifyUser: Boolean
}

input UpdateActionInput {
    action: UpdateAction!
    "Defaults to false. Whether or not FusionAuth will broadcast the User Action to any registered Webhooks."
    broadcast: Boolean
}

extend type Mutation {
    userAction(
        "Action to take"
        action: ActionInput!,
        "Defaults to False. Whether or not FusionAuth will broadcast the User Action to any registered Webhooks."
        broadcast: Boolean) : Action!


    "Update an in progress Action by Id"
    updateAction("The Id of the User Action being updated." actionId: UUID!,
                 "Update payload" patch: UpdateActionInput): Action

    "Update an in progress Action by Id"
    deleteAction("The Id of the User Action being updated." actionId: UUID!,
        "Update payload" patch: UpdateActionInput): Action
}


"A `Action` edge in the connection."
type ActionsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Actionf` at the end of the edge."
    node: Action
}

"A connection to a list of `Action` values."
type ActionsConnection {
    "A list of edges which contains the `Action` and cursor to aid in pagination."
    edges: [ActionsEdge!]!
    "A list of `Action` objects."
    nodes: [Action]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Action` you could get from the connection."
    totalCount: Int!
}

extend type Query {
    "Retrieve a specific User Action Log by Id"
    action("The unique Id of the Action to retrieve." actionId: UUID!) : Action

    "Retrieve all the Actions for a specific User by the User Id."
    actions("The unique Id of the User for which to retrieve all of the Actions."
        userId: UUID!,
        """When this parameter is provided and set to true, only active actions will be returned. When this parameter is provided and set to false, only the inactive actions will be returned. When this parameter is omitted, all actions will be returned.

        An active action is a time based action that has not yet expired or been canceled. An inactive action is either a time based action that has expired, canceled or an action that is not time based.

        This parameter and preventingLogin are mutually exclusive."""
        active: Boolean,
        """When this value is provided and set to true, only active actions that are preventing the user from login will be returned. Omitting this parameter, or setting this parameter to false does not affect the API behavior.

        This parameter and active are mutually exclusive because an action that is preventing login is always active."""
        preventingLogin: Boolean,
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "The number of search results to return. Used for pagination."
        last: Int,
        "The start row within the search results to return. Used for pagination."
        offset: Int) : ActionsConnection!
}

extend type User {
    "Retrieve all the Actions for a specific User by the User Id."
    actions(
        """When this parameter is provided and set to true, only active actions will be returned. When this parameter is provided and set to false, only the inactive actions will be returned. When this parameter is omitted, all actions will be returned.

        An active action is a time based action that has not yet expired or been canceled. An inactive action is either a time based action that has expired, canceled or an action that is not time based.

        This parameter and preventingLogin are mutually exclusive."""
        active: Boolean,
        """When this value is provided and set to true, only active actions that are preventing the user from login will be returned. Omitting this parameter, or setting this parameter to false does not affect the API behavior.

        This parameter and active are mutually exclusive because an action that is preventing login is always active."""
        preventingLogin: Boolean,
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "The number of search results to return. Used for pagination."
        last: Int,
        "The start row within the search results to return. Used for pagination."
        offset: Int) : ActionsConnection!
}

input CleanSpeakConfigurationUsernameModerationInput {
    "The Id of the CleanSpeak application that usernames are sent to for moderation."
    applicationId: UUID
    "Defaults to false. True if CleanSpeak username moderation is enabled."
    enabled: Boolean
}

input CleanSpeakConfigurationInput
{
"""An array of UUIDs that map to the CleanSpeak applications for this Application. It is possible that a single Application in FusionAuth might have multiple Applications in CleanSpeak. For example, a FusionAuth Application for a game might have one CleanSpeak Application for usernames and another Application for chat.

    This property is used when CleanSpeak sends user action notifications to FusionAuth (when users are disciplined for example). FusionAuth will translate the CleanSpeak ids to FusionAuth ids and then apply the user action."""
    applicationIds : [UUID]

    usernameModeration: CleanSpeakConfigurationUsernameModerationInput
}

input JwtConfigurationInput {
    "The Id of the signing key used to sign the access token."
    accessTokenId: UUID

    "Defaults to false. Indicates if this application is using the JWT configuration defined here or the global JWT configuration defined by the System Configuration. If this is false the signing algorithm configured in the System Configuration will be used. If true the signing algorithm defined in this application will be used."
    enabled: Boolean

    "The Id of the signing key used to sign the Id token."
    idTokenKeyId: UUID

    "The length of time in minutes the JWT refresh token will live before it is expired and is not able to be exchanged for a JWT. Required when enabled is set to true."
    refreshTokenTimeToLiveInMinutes: Int

    "The length of time in seconds the JWT will live before it is expired and no longer valid. Required when enabled is set to true."
    timeToLiveInSeconds: Int
}

input LambdaConfigurationInput {

    "The Id of the Lambda that will be invoked when an access token is generated for this application. This will be utilized during OAuth2 and OpenID Connect authentication requests as well as when an access token is generated for the Login API."
    accessTokenPopulateId: UUID

    "The Id of the Lambda that will be invoked when an Id token is generated for this application during an OpenID Connect authentication request."
    idTokenPopulateId: UUID

    "The Id of the Lambda that will be invoked when a a SAML response is generated during a SAML authentication request."
    samlv2PopulateId: UUID
}

input LoginConfigurationInput {
    """Indicates if a JWT may be refreshed using a Refresh Token for this application. This configuration is separate from issuing new Refresh Tokens which is controlled by the generateRefreshTokens parameter. This configuration indicates specifically if an existing Refresh Token may be used to request a new JWT using the Refresh API.

    If you do not intend to use the Login API, and instead will only be using the OAuth endpoints, you may leave this set to false to ensure Refresh Tokens cannot be used outside of the Refresh Token Grant."""
    allowTokenRefresh: Boolean

    """Defaults to false . Indicates if a Refresh Token should be issued from the Login API.

    If you do not intend to use the Login API, and instead will only be using the OAuth endpoints, you may leave this set to false to ensure Refresh Tokens will not be issued outside of the OAuth grants."""
    generateRefreshTokens: Boolean

    """Defaults to true. Indicates if the Login API should require an API key. If you set this value to false and your FusionAuth API is on a public network, anyone may attempt to use the Login API.

    If you do not intend to use the Login API, or will only be calling this API from a secure backend server, setting this value to true in order to require an API key is preferred."""
    requireAuthentication: Boolean
}

enum LogoutBehaviour {
    "End the SSO session and redirect to the configured Logout URL or the passed in post_logout_redirect_uri value."
    REDIRECT_ONLY,
    "End the SSO session and make a GET request to all configured Logout URLs for every application in the tenant."
    ALL_APPLICATIONS
}

input OAuthConfigurationInput {

    "An array of URLs that are the authorized origins for FusionAuth OAuth."
    authorizedOriginURLs : [String!]
    """An array of URLs that are the authorized redirect URLs for FusionAuth OAuth.

    Examples of valid redirect URIs:

     * https://example.com/redirect
     * com.myApp://redirect
     * com.myApp:/redirect

        You may now use URLs that do not begin with http to support native application redirect. Prior to this version the value will be validated to begin with http.
        You may now use URLs for application redirects that use a single slash to denote there is no naming authority for the scheme. Prior to this version a URL such as com.myApp:/redirect would fail validation as in invalid URL.
"""
    authorizedRedirectURLs : [String!]

    "The OAuth 2.0 client secret. If you leave this blank during a POST, a secure secret will be generated for you. If you leave this blank during PUT, the previous value will be maintained. For both POST and PUT you can provide a value and it will be stored."
    clientSecret : String

    "The device verification URL to be used with the Device Code grant type, this field is required when device_code is enabled."
    deviceVerificationURL : String

    """The enabled grants for this application. In order to utilize a particular grant with the OAuth 2.0 endpoints you must have enabled the grant.

    Supported values include:
     * authorization_code
     * implicit
     * password
     * refresh_token
     * device_code   

    """
    enabledGrants: String
    "Defaults to true . Determines if the OAuth 2.0 Token endpoint will generate a refresh token when the offline_access scope is requested."
    generateRefreshTokens: Boolean

    "Defaults to AllApplications  Behavior when /oauth2/logout is called."
    logoutBehavior : LogoutBehaviour


    "The logout URL for the Application. FusionAuth will redirect to this URL after the user logs out of OAuth."
    logoutURL : String

    "Defaults to true. Determines if the OAuth 2.0 Token endpoint requires client authentication. If this is enabled, the client must provide client credentials when using the Token endpoint. The client_id and client_secret may be provided using a Basic Authorization HTTP header, or by sending these parameters in the request body using POST data."
    requireClientAuthentication: Boolean

}

enum LoginType {EMAIL, USERNAME}

input RegistrationConfigurationFieldInput {
    "Defaults to false. Determines if the field will be included on the registration form."
    enabled: Boolean

    "Defaults to false. Determines if the field is required when displayed on the registration form."
    required: Boolean
}

input RegistrationConfigurationInput {
    birthDate: RegistrationConfigurationFieldInput

    "Defaults to false. Determines if the password should be confirmed during self service registration, this means that the user will be required to type the password twice."
    confirmPassword: Boolean

    "Defaults to false. Determines if self service registration is enabled for this application. When this value is false, you may still use the Registration API, this only affects if the self service option is available during the OAuth 2.0 login.     Self service registration cannot be enabled on the FusionAuth application."
    enabled: Boolean

    firstName: RegistrationConfigurationFieldInput
    fullName: RegistrationConfigurationFieldInput
    lastName: RegistrationConfigurationFieldInput

    "Defaults to EMAIL. The unique login Id that will be collected during registration, this value can be email or username. Leaving the default value of email is preferred because an email address is globally unique."
    loginIdType: LoginType

    middleName:  RegistrationConfigurationFieldInput
    mobilePhone: RegistrationConfigurationFieldInput
}

input RegistrationDeletePolicyUnverifiedInput {
    " Defaults to false . Indicates that users without a verified registration for this application will have their registration permanently deleted after application.registrationDeletePolicy.unverified.numberOfDaysToRetain days."
    enabled: Boolean

    "The number of days from registration a user’s registration will be retained before being deleted for not completing registration verification. This field is required when application.registrationDeletePolicy.enabled is set to true. Value must be greater than 0."
    numberOfDaysToRetain: Int
}

input RegistrationDeletePolicyInput {
    unverified: RegistrationDeletePolicyUnverifiedInput
}



input RoleInput {

    "A description for the role."
    description : String

    "Generated if null. The Id of the Role."
    id: UUID

    "The name of the Role."
    name: String!

    "Defaults to false. Whether or not the Role is a default role. A default role is automatically assigned to a user during registration if no roles are provided."
    isDefault: Boolean

    "Defaults to false. Whether or not the Role is a considered to be a super user role. This is a marker to indicate that it supersedes all other roles. FusionAuth will attempt to enforce this contract when using the web UI, it is not enforced programmatically when using the API."
    isSuperRole: Boolean
}


enum XmlSignatureC14nMethod {
    "The URI for this method is http://www.w3.org/2001/10/xml-exc-c14n"
    EXCLUSIVE,

    "The URI for this method is http://www.w3.org/2001/10/xml-exc-c14n#WithComments"
    EXCLUSIVE_WITH_COMMENTS,

    "The URI for this method is http://www.w3.org/TR/2001/REC-xml-c14n-20010315"
    INCLUSIVE,
    "The URI for this method is http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments"
    INCLUSIVE_WITH_COMMENTS

}

input Samlv2ConfigurationInput {
    "Defaults to issuer; The audience for the SAML response sent to back to the service provider from FusionAuth. Some service providers require different audience values than the issuer and this configuration option lets you change the audience in the response."
    audience: String

    "The URL of the callback (sometimes called the Assertion Consumer Service or ACS). This is where FusionAuth sends the browser after the user logs in via SAML."
    callbackURL: String!

    "Defaults to false. Whether or not FusionAuth will log SAML debug messages to the event log. This is useful for debugging purposes."
    debug: Boolean

    "Defaults to false. Whether or not the SAML IdP for this Application is enabled or not."
    enabled: Boolean

    "The issuer that identifies the service provider and allows FusionAuth to load the correct Application and SAML configuration. If you don’t know the issuer, you can often times put in anything here and FusionAuth will display an error message with the issuer from the service provider when you test the SAML login."
    issuer: String!

    "Defaults to a new key. The id of the Key used to sign the SAML response. If you do not specify this property, FusionAuth will create a new key and associate it with this Application."
    keyId: UUID

    "Defaults to the system logout URL or /. The URL that the browser is taken to after the user logs out of the SAML service provider. Often service providers need this URL in order to correctly hook up single-logout. Note that FusionAuth does not support the SAML single-logout profile because most service providers to not support it properly."
    logoutURL: String

    "Defaults to exclusive_with_comments. The XML signature canonicalization method used when digesting and signing the SAML response. Unfortunately, many service providers do not correctly implement the XML signature specifications and force a specific canonicalization method. This setting allows you to change the canonicalization method to match the service provider. Often, service providers don’t even document their required method. You might need to contact enterprise support at the service provider to figure out what method they use."
    xmlSignatureC14nMethod: XmlSignatureC14nMethod
}

input EnablableInput {
    enabled: Boolean
}

input ApplicationInput {
    "Defaults to false. Determines if Users can have Authentication Tokens associated with this Application. This feature may not be enabled for the FusionAuth application."
    authenticationTokenConfiguration: EnablableInput

    cleanSpeakConfiguration: CleanSpeakConfigurationInput

    "An object that can hold any information about the Application that should be persisted."
    data: JSON

    jwtConfiguration: JwtConfigurationInput

    lambdaConfiguration: LambdaConfigurationInput
    loginConfiguration: LoginConfigurationInput
    
    "The name of the Application."
    name: String
    
    oauthConfiguration: OAuthConfigurationInput
    "Defaults to false. Determines if passwordless login is enabled for this application."
    passwordlessConfiguration: EnablableInput

    registrationConfiguration: RegistrationConfigurationInput
    registrationDeletePolicy: RegistrationDeletePolicyInput

    "An array of Role objects."
    roles: [RoleInput!]

    samlv2Configuration: Samlv2ConfigurationInput

    "The Id of the Email Template that is used to send the Registration Verification emails to users. If the verifyRegistration field is true this field is required."
    verificationEmailTemplateId: UUID

    "Defaults to false. Whether or not registrations to this Application may be verified. When this is set to true the verificationEmailTemplateId parameter is also required."
    verifyRegistration : Boolean
}

type Enablable {
    enabled: Boolean!
}

type CleanSpeakConfigurationUsernameModeration {
    "The Id of the CleanSpeak application that usernames are sent to for moderation."
    applicationId: UUID!
    "Defaults to false. True if CleanSpeak username moderation is enabled."
    enabled: Boolean!
}


type JwtConfiguration {
    "The Id of the signing key used to sign the access token."
    accessTokenId: UUID!
    accessToken: Key

    "Defaults to false. Indicates if this application is using the JWT configuration defined here or the global JWT configuration defined by the System Configuration. If this is false the signing algorithm configured in the System Configuration will be used. If true the signing algorithm defined in this application will be used."
    enabled: Boolean!

    "The Id of the signing key used to sign the Id token."
    idTokenKeyId: UUID!
    idTokenKey: Key

    "The length of time in minutes the JWT refresh token will live before it is expired and is not able to be exchanged for a JWT. Required when enabled is set to true."
    refreshTokenTimeToLiveInMinutes: Int!

    "The length of time in seconds the JWT will live before it is expired and no longer valid. Required when enabled is set to true."
    timeToLiveInSeconds: Int!
}


type LambdaConfiguration {

    "The Id of the Lambda that will be invoked when an access token is generated for this application. This will be utilized during OAuth2 and OpenID Connect authentication requests as well as when an access token is generated for the Login API."
    accessTokenPopulateId: UUID!
    accessTokenPopulate: Lambda

    "The Id of the Lambda that will be invoked when an Id token is generated for this application during an OpenID Connect authentication request."
    idTokenPopulateId: UUID!
    idTokenPopulate: Lambda

    "The Id of the Lambda that will be invoked when a a SAML response is generated during a SAML authentication request."
    samlv2PopulateId: UUID!
    samlv2Populate: Lambda
}

type LoginConfiguration {
    """Indicates if a JWT may be refreshed using a Refresh Token for this application. This configuration is separate from issuing new Refresh Tokens which is controlled by the generateRefreshTokens parameter. This configuration indicates specifically if an existing Refresh Token may be used to request a new JWT using the Refresh API.

    If you do not intend to use the Login API, and instead will only be using the OAuth endpoints, you may leave this set to false to ensure Refresh Tokens cannot be used outside of the Refresh Token Grant."""
    allowTokenRefresh: Boolean!

    """Defaults to false . Indicates if a Refresh Token should be issued from the Login API.

    If you do not intend to use the Login API, and instead will only be using the OAuth endpoints, you may leave this set to false to ensure Refresh Tokens will not be issued outside of the OAuth grants."""
    generateRefreshTokens: Boolean!

    """Defaults to true. Indicates if the Login API should require an API key. If you set this value to false and your FusionAuth API is on a public network, anyone may attempt to use the Login API.

    If you do not intend to use the Login API, or will only be calling this API from a secure backend server, setting this value to true in order to require an API key is preferred."""
    requireAuthentication: Boolean!
}


type OAuthConfiguration {

    "An array of URLs that are the authorized origins for FusionAuth OAuth."
    authorizedOriginURLs : [String!]!
    """An array of URLs that are the authorized redirect URLs for FusionAuth OAuth.

    Examples of valid redirect URIs:

    * https://example.com/redirect
    * com.myApp://redirect
    * com.myApp:/redirect

    You may now use URLs that do not begin with http to support native application redirect. Prior to this version the value will be validated to begin with http.
    You may now use URLs for application redirects that use a single slash to denote there is no naming authority for the scheme. Prior to this version a URL such as com.myApp:/redirect would fail validation as in invalid URL.
    """
    authorizedRedirectURLs : [String!]!

    "The OAuth client Id of the Application."
    clientId: String!


    "The OAuth 2.0 client secret. If you leave this blank during a POST, a secure secret will be generated for you. If you leave this blank during PUT, the previous value will be maintained. For both POST and PUT you can provide a value and it will be stored."
    clientSecret : String!

    "The device verification URL to be used with the Device Code grant type, this field is required when device_code is enabled."
    deviceVerificationURL : String!

    """The enabled grants for this application. In order to utilize a particular grant with the OAuth 2.0 endpoints you must have enabled the grant.

    Supported values include:
    * authorization_code
    * implicit
    * password
    * refresh_token
    * device_code   

    """
    enabledGrants : [String!]!
    "Defaults to true . Determines if the OAuth 2.0 Token endpoint will generate a refresh token when the offline_access scope is requested."
    generateRefreshTokens: Boolean!

    "Defaults to AllApplications  Behavior when /oauth2/logout is called."
    logoutBehavior : LogoutBehaviour!


    "The logout URL for the Application. FusionAuth will redirect to this URL after the user logs out of OAuth."
    logoutURL : String!

    "Defaults to true. Determines if the OAuth 2.0 Token endpoint requires client authentication. If this is enabled, the client must provide client credentials when using the Token endpoint. The client_id and client_secret may be provided using a Basic Authorization HTTP header, or by sending these parameters in the request body using POST data."
    requireClientAuthentication: Boolean!

}

type CleanSpeakConfiguration
{
    """An array of UUIDs that map to the CleanSpeak applications for this Application. It is possible that a single Application in FusionAuth might have multiple Applications in CleanSpeak. For example, a FusionAuth Application for a game might have one CleanSpeak Application for usernames and another Application for chat.

    This property is used when CleanSpeak sends user action notifications to FusionAuth (when users are disciplined for example). FusionAuth will translate the CleanSpeak ids to FusionAuth ids and then apply the user action."""
    applicationIds : [UUID]
    applications(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int) : ApplicationsConnection

    "True if CleanSpeak integration is enabled. This setting is global and is not modifiable using this API."
    enabled: Boolean!
    "The Id of the CleanSpeak application that usernames are sent to for moderation."
    usernameModeration: CleanSpeakConfigurationUsernameModeration!
}


type RegistrationConfigurationField {
    "Defaults to false. Determines if the field will be included on the registration form."
    enabled: Boolean

    "Defaults to false. Determines if the field is required when displayed on the registration form."
    required: Boolean
}

type RegistrationConfiguration {
    birthDate: RegistrationConfigurationField!

    "Defaults to false. Determines if the password should be confirmed during self service registration, this means that the user will be required to type the password twice."
    confirmPassword: Boolean!

    "Defaults to false. Determines if self service registration is enabled for this application. When this value is false, you may still use the Registration API, this only affects if the self service option is available during the OAuth 2.0 login.     Self service registration cannot be enabled on the FusionAuth application."
    enabled: Boolean!

    firstName: RegistrationConfigurationField!
    fullName: RegistrationConfigurationField!
    lastName: RegistrationConfigurationField!

    "Defaults to EMAIL. The unique login Id that will be collected during registration, this value can be email or username. Leaving the default value of email is preferred because an email address is globally unique."
    loginIdType: LoginType

    middleName:  RegistrationConfigurationField!
    mobilePhone: RegistrationConfigurationField!

}

type RegistrationDeletePolicyUnverified {
    " Defaults to false . Indicates that users without a verified registration for this application will have their registration permanently deleted after application.registrationDeletePolicy.unverified.numberOfDaysToRetain days."
    enabled: Boolean!

    "The number of days from registration a user’s registration will be retained before being deleted for not completing registration verification. This field is required when application.registrationDeletePolicy.enabled is set to true. Value must be greater than 0."
    numberOfDaysToRetain: Int!
}

type RegistrationDeletePolicy {
    unverified: RegistrationDeletePolicyUnverified!
}

type Role {

    "A description for the role."
    description : String!

    "Generated if null. The Id of the Role."
    id: UUID!

    "The name of the Role."
    name: String!

    "Defaults to false. Whether or not the Role is a default role. A default role is automatically assigned to a user during registration if no roles are provided."
    isDefault: Boolean!

    "Defaults to false. Whether or not the Role is a considered to be a super user role. This is a marker to indicate that it supersedes all other roles. FusionAuth will attempt to enforce this contract when using the web UI, it is not enforced programmatically when using the API."
    isSuperRole: Boolean!
}


type Samlv2Configuration {
    "Defaults to issuer; The audience for the SAML response sent to back to the service provider from FusionAuth. Some service providers require different audience values than the issuer and this configuration option lets you change the audience in the response."
    audience: String!

    "The URL of the callback (sometimes called the Assertion Consumer Service or ACS). This is where FusionAuth sends the browser after the user logs in via SAML."
    callbackURL: String!

    "Defaults to false. Whether or not FusionAuth will log SAML debug messages to the event log. This is useful for debugging purposes."
    debug: Boolean!

    "Defaults to false. Whether or not the SAML IdP for this Application is enabled or not."
    enabled: Boolean!

    "The issuer that identifies the service provider and allows FusionAuth to load the correct Application and SAML configuration. If you don’t know the issuer, you can often times put in anything here and FusionAuth will display an error message with the issuer from the service provider when you test the SAML login."
    issuer: String!

    "Defaults to a new key. The id of the Key used to sign the SAML response. If you do not specify this property, FusionAuth will create a new key and associate it with this Application."
    keyId: UUID!
    key: Key

    "Defaults to the system logout URL or /. The URL that the browser is taken to after the user logs out of the SAML service provider. Often service providers need this URL in order to correctly hook up single-logout. Note that FusionAuth does not support the SAML single-logout profile because most service providers to not support it properly."
    logoutURL: String!

    "Defaults to exclusive_with_comments. The XML signature canonicalization method used when digesting and signing the SAML response. Unfortunately, many service providers do not correctly implement the XML signature specifications and force a specific canonicalization method. This setting allows you to change the canonicalization method to match the service provider. Often, service providers don’t even document their required method. You might need to contact enterprise support at the service provider to figure out what method they use."
    xmlSignatureC14nMethod: XmlSignatureC14nMethod!
}

type Application {
    "The Id of the Application."
    id: UUID!

    "Whether or not the Application is active."
    active: Boolean!

    "Whether or not Users can have Authentication Tokens associated with this Application."
    authenticationTokenConfiguration: Enablable!

    cleanSpeakConfiguration: CleanSpeakConfiguration


    "An object that can hold any information about the Application that should be persisted."
    data: JSON

    jwtConfiguration: JwtConfiguration

    lambdaConfiguration: LambdaConfiguration
    loginConfiguration: LoginConfiguration

    "The name of the Application."
    name: String

    oauthConfiguration: OAuthConfiguration
    "Defaults to false. Determines if passwordless login is enabled for this application."
    passwordlessConfiguration: Enablable

    registrationConfiguration: RegistrationConfiguration
    registrationDeletePolicy: RegistrationDeletePolicy

    "An array of Role objects."
    roles: [Role!]

    samlv2Configuration: Samlv2Configuration

    "The Id of the Email Template that is used to send the Registration Verification emails to users. If the verifyRegistration field is true this field is required."
    verificationEmailTemplateId: UUID!
    verificationEmailTemplate: EmailTemplate

    "Defaults to false. Whether or not registrations to this Application may be verified. When this is set to true the verificationEmailTemplateId parameter is also required."
    verifyRegistration : Boolean!
}

extend type Mutation {
    "Create an Application"
    createApplication(applicationId: UUID, data: ApplicationInput,
        "An array of Webhook Ids. For Webhooks that are not already configured for All Applications, specifying an Id on this request will indicate the associated Webhook should handle events for this application."
        webhookIds: [UUID!]) : Application

    "Update an Application"
    updateApplication(applicationId: UUID!, data: ApplicationInput,
        "An array of Webhook Ids. For Webhooks that are not already configured for All Applications, specifying an Id on this request will indicate the associated Webhook should handle events for this application."
        webhookIds: [UUID!]) : Application

    reactivateApplication(applicationid: UUID!) : Application

    "This API is used to reactivate an inactive Application."
    deleteAppliation(applicationId: UUID!,
        "Permanently delete an Application. This operation cannot be reversed."
        hardDelete: Boolean) : Boolean

    "Create a Role"
    createRole(
        "The Id of the Application."
        applicationId: UUID!,
        role: RoleInput) : Role

    "Create a Role"
    updateRole(
        "The Id of the Application."
        applicationId: UUID!,
        roleId: UUID!,
        role: RoleInput) : Role

    deleteRole(applicationId: UUID!, roleId: UUID!) : Boolean
    deleteRoleByName(applicationId: UUID!, name: String!) : Boolean
}

"A `Application` edge in the connection."
type ApplicationsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Application` at the end of the edge."
    node: Application
}

"A connection to a list of `Application` values."
type ApplicationsConnection {
    "A list of edges which contains the `Application` and cursor to aid in pagination."
    edges: [ApplicationsEdge!]!
    "A list of `Application` objects."
    nodes: [Application]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Application` you could get from the connection."
    totalCount: Int!
}


extend type Query {
    "Retrieve all applications"
    applications(
        "Set this parameter to true in order to retrieve only inactive Applications. Setting this parameter to false is equivalent omitting the inactive parameter"
        inactive: Boolean,
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
    ) : ApplicationsConnection!

    application(applicationId: UUID!) : Application
    applicationOAuthConfiguration(applicationId: UUID!): OAuthConfiguration
}

input AuditLogInput {
    "An object that can hold additional details of an audit log."
    data: JSON
    "Intended to be utilized during a change to record the new value."
    newValue: String
    "Intended to be utilized during a change to record the old value prior to the change."
    oldValue: String
    "Intended to be utilized during a change to indicate the reason for the modification."
    reason: String
    "The user that took the action that is being written to the Audit Logs. We suggest you use email addresses for this field."
    insertUser: String!
    "The message of the Audit Log."
    message: String!
}

extend type Mutation {
    createAuditLog(log: AuditLogInput) : Boolean
}

type AuditLog {
    "Additional details of an audit log."
    data: JSON

    "The new value of a changed object."
    newValue : String!

    "The previous value of a changed object."
    oldValue : String!

    "The reason why the audit log was created."
    reason : String!

    "The Audit Log unique Id."
    id : Int

    "The instant when the Audit Log was created."
    insertInstant: Int

    "The user that created the Audit Log."
    insertUser : String!

    "The message of the Audit Log."
    message : String!
}

"A `AuditLog` edge in the connection."
type AuditLogsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `AuditLog` at the end of the edge."
    node: AuditLog
}

"A connection to a list of `AuditLog` values."
type AuditLogsConnection {
    "A list of edges which contains the `AuditLog` and cursor to aid in pagination."
    edges: [AuditLogsEdge!]!
    "A list of `AuditLog` objects."
    nodes: [AuditLog]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `AuditLog` you could get from the connection."
    totalCount: Int!
}

input LogsCondition {
    "The start instant of the date/time range to search within."
    start: Int,
    "The end instant of the date/time range to search within."
    end: Int,
    "The string to search in the Audit Log message for. This can contain wildcards using the asterisk or percent characters (* or %)."
    message: String,
    "The string to search in the Audit Log user for. This can contain wildcards using the asterisk or percent characters (* or %)."
    user: String
}

enum OrderLogsBy {
    INSERT_INSTANT_DESC,
    INSERT_INSTANT_ASC,
    INSERT_USER_DESC,
    INSERT_USER_ASC,
    INSERT_MESSAGE_DESC,
    INSERT_MESSAGE_ASC,
}

extend type Query {
    auditLog(logId: UUID) : AuditLog
    searchAuditLog(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: LogsCondition,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The database column to order the search results on plus the order direction."
        orderBy: OrderLogsBy) : AuditLogsConnection!
}

input ConsentEMailPlusInput {

    """Defaults to false.
    Set this value to true to enable the Email Plus workflow.

    Email Plus provides and additional opportunity to notify the giver that consent was provided. For example, if consentEmailTemplateId is provided then when the consent is granted an email will be sent to notify the giver that consent was granted to the user. When using Email Plus a follow up email will be sent to the giver at a randomly selected time within the configured minimum and maximum range of hours."""
    enabled: Boolean

    "The Id of the Email Template that is used to send the reminder notice to the consent giver. This value is required when emailPlus.enabled is set to true."
    emailTemplateId: UUID!

    "Defaults to 48. The maximum number of hours to wait until sending the reminder notice the consent giver."
    maximumTimeToSendEmailInHours: Int

    "Defaults to 24. The minimum number of hours to wait until sending the reminder notice the consent giver."
    minimumTimeToSendEmailInHours: Int
}

input ConsentMininumAgeByLocaleInput {
    locale: Locale!
    age: Int!
}

input ConsentInput {
    "The Id of the Email Template that is used to send confirmation to the end user. If this value is omitted an email will not be sent to the user."
    consentEmailTemplateId: UUID
"""
The Id of the Email Template that is used to send confirmation to the end user. If this value is omitted an email will not be sent to the user.

consent.countryMinimumAgeForSelfConsent [Map<Locale, Integer>] OPTIONAL
This property optionally overrides the value provided in defaultMinimumAgeForSelfConsent if a more specific value is defined. This can be useful when the age of self consent varies by country.

For example, consider the following definition:
```
{
  "de": 17
}
```
If a user has defined their preferred locale to be Germany (de), the age of self consent defined for Germany will be used instead of the value defined by defaultMinimumAgeForSelfConsent.
"""
    countryMinimumAgeForSelfConsent: [ConsentMininumAgeByLocaleInput]

"""The default age of self consent used when granting this consent to a user unless a more specific one is provided by the countryMinimumAgeForSelfConsent.

A user that meets the minimum age of self consent may self-consent, this means the recipient may also be the giver."""
    defaultMinimumAgeForSelfConsent: Int

    emailPlus: ConsentEMailPlusInput
    """Defaults to false
Set this value to true if more than one value may be used when granting this consent to a User. When this value is false a maximum of one value may be assigned.

This value is not used when no values have been defined for this consent."""
    multipleValuesAllowed: Boolean

    "The unique name of the consent."
    name: String!

    "One or more values that may be assigned for this consent."
    values: [String!]
}

type ConsentEMailPlus {

    """Defaults to false.
    Set this value to true to enable the Email Plus workflow.

    Email Plus provides and additional opportunity to notify the giver that consent was provided. For example, if consentEmailTemplateId is provided then when the consent is granted an email will be sent to notify the giver that consent was granted to the user. When using Email Plus a follow up email will be sent to the giver at a randomly selected time within the configured minimum and maximum range of hours."""
    enabled: Boolean!

    "The Id of the Email Template that is used to send the reminder notice to the consent giver. This value is required when emailPlus.enabled is set to true."
    emailTemplateId: UUID!
    emailTemplate: EmailTemplate

    "Defaults to 48. The maximum number of hours to wait until sending the reminder notice the consent giver."
    maximumTimeToSendEmailInHours: Int!

    "Defaults to 24. The minimum number of hours to wait until sending the reminder notice the consent giver."
    minimumTimeToSendEmailInHours: Int!
}

type ConsentMininumAgeByLocale{
    locale: Locale!
    age: Int!
}

type Consent {
    "The Id of the Email Template that is used to send confirmation to the end user. If this value is omitted an email will not be sent to the user."
    consentEmailTemplateId: UUID!
    consentEmailTemplate: EmailTemplate
    """
    The Id of the Email Template that is used to send confirmation to the end user. If this value is omitted an email will not be sent to the user.

    consent.countryMinimumAgeForSelfConsent [Map<Locale, Integer>] OPTIONAL
    This property optionally overrides the value provided in defaultMinimumAgeForSelfConsent if a more specific value is defined. This can be useful when the age of self consent varies by country.

    For example, consider the following definition:
    ```
    {
    "de": 17
    }
    ```
    If a user has defined their preferred locale to be Germany (de), the age of self consent defined for Germany will be used instead of the value defined by defaultMinimumAgeForSelfConsent.
    """
    countryMinimumAgeForSelfConsent: [ConsentMininumAgeByLocale]!

    """The default age of self consent used when granting this consent to a user unless a more specific one is provided by the countryMinimumAgeForSelfConsent.

    A user that meets the minimum age of self consent may self-consent, this means the recipient may also be the giver."""
    defaultMinimumAgeForSelfConsent: Int!

    emailPlus: ConsentEMailPlus!

    "The unique Id of the consent."
    id: UUID!

    """Defaults to false
    Set this value to true if more than one value may be used when granting this consent to a User. When this value is false a maximum of one value may be assigned.

    This value is not used when no values have been defined for this consent."""
    multipleValuesAllowed: Boolean!

    "The unique name of the consent."
    name: String!

    "One or more values that may be assigned for this consent."
    values: [String!]!
}

extend type Mutation {
    createConsent(consentId: UUID, input: ConsentInput) : Consent
    updateConsent(consentId: UUID!, input: ConsentInput) : Consent
    deleteConsent(consentId: UUID!) : Boolean
}

"A `Consent` edge in the connection."
type ConsentsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Consent` at the end of the edge."
    node: Consent
}

"A connection to a list of `Consent` values."
type ConsentsConnection {
    "A list of edges which contains the `Consent` and cursor to aid in pagination."
    edges: [ConsentsEdge!]!
    "A list of `Consent` objects."
    nodes: [Consent]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Consent` you could get from the connection."
    totalCount: Int!
}



extend type Query {
    consent(constentId: UUID) : Consent
    consents(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int) : ConsentsConnection!
}

input UserConsentInput {
    "The Id of the Consent being granted to the User."
    consentId: UUID!

    "The Id of the User giving consent. When providing self-consent the giverUserId will be the same as the userId."
    giverUserId: UUID!
    "The Id of the User receiving consent. When providing self-consent the giverUserId will be the same as the userId."
    userId: UUID!

    "The consent values to be associated with this User consent."
    values: [String!]
}

enum UserConsentStatus {
    ACTIVE, REVOKED
}

type UserConsent {
    "The Consent object represented by the consentId field."
    consent: Consent!

    "The Id of the Consent being granted to the User."
    consentId: UUID!

    "The Id of the User giving consent. When providing self-consent the giverUserId will be the same as the userId."
    giverUserId: UUID!
    giverUser: User

    "The unique Id of the User consent."
    id: UUID!

    "The instant when the User consent was granted."
    insertInstant: Int!

    "The instant when the User consent was last updated."
    lastUpdateInstant: Int!

    "The current status of the User consent"
    status: UserConsentStatus!


    "The Id of the User receiving consent. When providing self-consent the giverUserId will be the same as the userId."
    userId: UUID!
    user: User

    "The consent values to be associated with this User consent."
    values: [String!]!
}


extend type Mutation {

    createUserConsent(consentId: UUID,  input: UserConsentInput) : UserConsent
    "This API is used to update a consent. Once consent has been granted to a User, only the values and status may be modified."
    updateUserConsent(consentId: UUID!, input: UserConsentInput) : UserConsent
    "Revoke a User Consent with given Id"
    deleteUserConsent(consentId: UUID!) : Boolean
}



"A ` UserConsent` edge in the connection."
type  UserConsentsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The ` UserConsent` at the end of the edge."
    node:  UserConsent
}

"A connection to a list of ` UserConsent` values."
type  UserConsentsConnection {
    "A list of edges which contains the ` UserConsent` and cursor to aid in pagination."
    edges: [ UserConsentsEdge!]!
    "A list of ` UserConsent` objects."
    nodes: [ UserConsent]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* ` UserConsent` you could get from the connection."
    totalCount: Int!
}

extend type Query {
    userConsent(constentId: UUID) : UserConsent
    userConsents(
        "The unique Id of the User to retrieve User Consents for."
        userId: UUID!
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int) : UserConsentsConnection!
}

extend type User {
    userConsents(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int) : UserConsentsConnection!
}

input LocalizedStringInput {
    locale: Locale
    template: String
}

input EmailTemplateInput {
    "The default From Name used when sending emails. If not provided, and a localized value cannot be determined, the default value for the tenant will be used. This is the display name part of the email address ( i.e. Jared Dunn <jared@piedpiper.com>)."
    defaultFromName : String

    "The default HTML Email Template."
    defaultHtmlTemplate : String!

    "The default Subject used when sending emails."
    defaultSubject : String!

    "The default Text Email Template."
    defaultTextTemplate : String!

    "The email address that this email will be sent from. If not provided, the default value for the tenant will be used. This is the address part email address (i.e. Jared Dunn <jared@piedpiper.com>)."
    fromEmail  : String

    "The From Name used when sending emails to users who speak other languages. This overrides the default From Name based on the user’s list of preferred languages."
    localizedFromNames: [LocalizedStringInput!]

    "The HTML Email Template used when sending emails to users who speak other languages. This overrides the default HTML Email Template based on the user’s list of preferred languages."
    localizedHtmlTemplates: [LocalizedStringInput!]

    "The Subject used when sending emails to users who speak other languages. This overrides the default Subject based on the user’s list of preferred languages."
    localizedSubjects: LocalizedStringInput!

    "The Text Email Template used when sending emails to users who speak other languages. This overrides the default Text Email Template based on the user’s list of preferred languages."
    localizedTextTemplates: [LocalizedStringInput!]

    "A descriptive name for the email template (i.e. \"April 2016 Coupon Email\")"
    name: String!
}

input EmailTemplatePreviewInput {
    "The default From Name used when sending emails. If not provided, and a localized value cannot be determined, the default value for the tenant will be used. This is the display name part of the email address ( i.e. Jared Dunn <jared@piedpiper.com>)."
    defaultFromName : String

    "The default HTML Email Template."
    defaultHtmlTemplate : String!

    "The default Subject used when sending emails."
    defaultSubject : String!

    "The default Text Email Template."
    defaultTextTemplate : String!

    "The email address that this email will be sent from. If not provided, the default value for the tenant will be used. This is the address part email address (i.e. Jared Dunn <jared@piedpiper.com>)."
    fromEmail: String

    "The From Name used when sending emails to users who speak other languages. This overrides the default From Name based on the user’s list of preferred languages."
    localizedFromNames: [LocalizedStringInput!]

    "The HTML Email Template used when sending emails to users who speak other languages. This overrides the default HTML Email Template based on the user’s list of preferred languages."
    localizedHtmlTemplates: [LocalizedStringInput!]

    "The Subject used when sending emails to users who speak other languages. This overrides the default Subject based on the user’s list of preferred languages."
    localizedSubjects: [LocalizedStringInput!]

    "The Text Email Template used when sending emails to users who speak other languages. This overrides the default Text Email Template based on the user’s list of preferred languages."
    localizedTextTemplates: [LocalizedStringInput!]

    "A descriptive name for the email template (i.e. \"April 2016 Coupon Email\")"
    locale: Locale!
}

type LocalizedString {
    locale: Locale
    value: String
}

type EmailTemplate {
    "The default From Name used when sending emails. If not provided, and a localized value cannot be determined, the default value for the tenant will be used. This is the display name part of the email address ( i.e. Jared Dunn <jared@piedpiper.com>)."
    defaultFromName : String

    "The default HTML Email Template."
    defaultHtmlTemplate : String!

    "The default Subject used when sending emails."
    defaultSubject : String!

    "The default Text Email Template."
    defaultTextTemplate : String!

    "The email address that this email will be sent from. If not provided, the default value for the tenant will be used. This is the address part email address (i.e. Jared Dunn <jared@piedpiper.com>)."
    fromEmail  : String

    "The Id of Email Template."
    id: UUID!

    "The From Name used when sending emails to users who speak other languages. This overrides the default From Name based on the user’s list of preferred languages."
    localizedFromNames: [LocalizedString!]

    "The HTML Email Template used when sending emails to users who speak other languages. This overrides the default HTML Email Template based on the user’s list of preferred languages."
    localizedHtmlTemplates: [LocalizedString!]

    "The Subject used when sending emails to users who speak other languages. This overrides the default Subject based on the user’s list of preferred languages."
    localizedSubjects: [LocalizedString!]

    "The Text Email Template used when sending emails to users who speak other languages. This overrides the default Text Email Template based on the user’s list of preferred languages."
    localizedTextTemplates: [LocalizedString!]

    "A descriptive name for the email template (i.e. \"April 2016 Coupon Email\")"
    name: String!
}

extend type Mutation {
    createEmailTemplate(emailTemplateId: UUID,  emailTemplate: EmailTemplateInput!) : EmailTemplate
    updateEmailTemplate(emailTemplateId: UUID!, emailTemplate: EmailTemplateInput!) : EmailTemplate
    deleteEmailTemplate(emailTemplateId: UUID!) : Boolean
}

"A `EmailTemplate` edge in the connection."
type EmailTemplatesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `EmailTemplate` at the end of the edge."
    node: EmailTemplate
}

"A connection to a list of `EmailTemplate` values."
type EmailTemplatesConnection {
    "A list of edges which contains the `EmailTemplate` and cursor to aid in pagination."
    edges: [EmailTemplatesEdge!]!
    "A list of `EmailTemplate` objects."
    nodes: [EmailTemplate]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `EmailTemplate` you could get from the connection."
    totalCount: Int!
}

type EmailFrom {
    "The email address that this email will be sent from. This is the address part email address (i.e. Jared Dunn <jared@piedpiper.com>)."
    address: String!
    "The From display name this email will be sent from. This is the name part email address ( i.e. Jared Dunn <jared@piedpiper.com>)."
    display: String!

}

type EmailTemplatePreview {
    from: EmailFrom!
    "The HTML Email."
    html: String!
    "The Subject used when sending the email."
    subject: String!
    "The Text Email."
    email: String
    "An Errors object that contains any errors in the Email Template."
    errors: [Errors!]
}

type TemplateError {
    key: String!
    message: String!
}

type SentEmails {
    userId: UUID!
    user: User
    parseErrors: [TemplateError!]
    renderErrors: [TemplateError!]
}

extend type Query {
    emailTemplate(emailTemplateId: UUID!) : EmailTemplate
    emailTemplates(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,

        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
    ): EmailTemplatesConnection!
    "This API is used to preview an Email Template. You simply pass all of the information for the Email Template in the request and rendered version of the Email is sent back to you in the response. The Email Template in the request does not need to be completely filled out either. You can send in a partial Email Template and the response will contain only what you provided."
    previewEmailTemplate(template : EmailTemplatePreviewInput) : EmailTemplatePreview
}

extend type EmailTemplate {
    previewEmailTemplate: EmailTemplatePreview
}

extend type Mutation
{
    "This API is used to send an Email to one or more users using an Email Template."
    sendEmails(emailTemplateId: UUID!,
                bccAddresses: [String!], ccAddresses: [String!],
               requestData: JSON, userIds: [UUID!]!) : SentEmails
}

enum EventLogType {INFORMATION, DEBUG, ERROR}

type EventLog {
    "The event Log unique Id."
    id: UUID!
    "The instant when the Event Log was created."
    insertInstant: Int!
    "The message of the event Log."
    message: String!
    "The type of the Event Log"
    type: EventLogType!
}

"A `EventLog` edge in the connection."
type EventLogsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `EventLog` at the end of the edge."
    node: EventLog
}

"A connection to a list of `EventLog` values."
type EventLogsConnection {
    "A list of edges which contains the `EventLog` and cursor to aid in pagination."
    edges: [EventLogsEdge!]!
    "A list of `EventLog` objects."
    nodes: [EventLog]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `EventLog` you could get from the connection."
    totalCount: Int!
}


extend type Query {
    "Retrieve an Event Log by Id"
    eventLog(logId: UUID!): EventLog
    "Searches the Event Logs using the given search criteria"
    searchEventLogs(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: LogsCondition,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The database column to order the search results on plus the order direction."
        orderBy: OrderLogsBy) : EventLogsConnection!
}

enum FamilyRole {ADULT, CHILD, TEEN}

input FamilyMemberInput {
    "The unique userId of the User to add to a family."
    userId: UUID!

    "Defaults to false. Set to true to indicate a family owner. This value will be ignored if the user role is Teen or Child."
    owner: Boolean

    "The role of the user in the family. When creating a family the first user must be an Adult, this value must be set to Adult."
    role : FamilyRole!
}


type FamilyMember {
    "The unique userId of the User to add to a family."
    userId: UUID!
    user: User

    "True if this user is the owner of the family, the first Adult user in the family will automatically be set as the owner. A teen or child cannot be the family owner."
    owner: Boolean!

    "The role of the user in the family. When creating a family the first user must be an Adult, this value must be set to Adult."
    role : FamilyRole!

    "The instant when the user was added to the family."
    insertInstant: Int!
}

type Family {
    "The unique Id of the family."
    id: UUID!

    "The members of this family."
    members: [FamilyMember!]!

    pendingMembers : [User!]
}

extend type Mutation {
    addFamilyMember(
        member: FamilyMemberInput!,
        "The Id to use for the new Family. If not specified a secure random UUID will be generated."
        familyId: UUID) : Family

    updateFamilyMember(
        member: FamilyMemberInput!,
        "The Id to use for the new Family. If not specified a secure random UUID will be generated."
        familyId: UUID!) : Family
    "Remove a User from a Family"
    deleteFamilyMember("The unique Id of the Family." familyId: UUID!,
                       "The unique Id of the User."     userId: UUID!) : Boolean
}

extend type Query {
    family(familyId: UUID) : Family
    pendingFamilyMembers(parentEmail: String!) : [User!]
}

extend type Mutation {
    requestParentalApproval(parentEmail: String!): Boolean
}

input GroupInput {
    "An object that can hold any information about the Group that should be persisted."
    data: JSON!

    "The name of the Group."
    name: String!
}

type RolesByApplicationId{
    applicationId: UUID!
    roles: [Role!]!
}

type Group {
    "An object that can hold any information about the Group that should be persisted."
    data: JSON!

    "The unique Id of the Group."
    id: UUID!

    "The name of the Group."
    name: String!

    "The roles assigned to this Group. The map key is the Application Id, the value is an array of Application Roles."
    roles: [RolesByApplicationId!]!
}

input GroupMembershipInput {
    "An object that can hold any information about the Group Member that should be persisted."
    data: JSON

    "The unique Id of this Group Member. If not specified a secure random UUID will be generated."
    id: UUID

    "The User Id to add as a Member of this Group."
    userId: UUID!
}

input GroupMembershipsInput {
    groupId: UUID!
    members: [GroupMembershipInput!]!
}


type GroupMembership {
    "An object that can hold any information about the Group Member that should be persisted."
    data: JSON

    "The unique Id of this Group Member. If not specified a secure random UUID will be generated."
    id: UUID

    "The instant that this membership was created."
    insertInstant: Int

    "The User Id to add as a Member of this Group."
    userId: UUID!
    user: User
}

type GroupMemberships {
    groupId: UUID!
    group: Group
    members: [GroupMembership!]!
}

extend type Mutation {
    createGroup(groupId: UUID,  input: GroupInput!, roleIds: [UUID!]) : Group
    updateGroup(groupId: UUID!, input: GroupInput!, roleIds: [UUID!]) : Group
    deleteGroup(groupId: UUID!) : Boolean

    addUsersToGroup(groupMemberships: [GroupMembershipsInput!]!) : GroupMemberships
    removeGroupMember(memberId: UUID!) : Boolean
    removeGroupMembers(memberId: [UUID!]!) : Boolean
    removeGroupMemberByGroupAndUserId(groupId: UUID!, userId: UUID!) : Boolean
    removeGroupMembersByGroupAndUserId(groupId: UUID!, userId: [UUID!]!) : Boolean
    removeAllGroupMembers(groupId: UUID!): Boolean
}

"A `Group` edge in the connection."
type GroupsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Group` at the end of the edge."
    node: Group
}

"A connection to a list of `Group` values."
type GroupsConnection {
    "A list of edges which contains the `Group` and cursor to aid in pagination."
    edges: [GroupsEdge!]!
    "A list of `Group` objects."
    nodes: [Group]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Group` you could get from the connection."
    totalCount: Int!
}

extend type Query {
    group(groupId: UUID!) : Group
    groups(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
    ): GroupsConnection}

interface IdentityProvider {
    type: String
}

"A `IdentityProvider` edge in the connection."
type IdentityProvidersEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `IdentityProvider` at the end of the edge."
    node: IdentityProvider
}

"A connection to a list of `IdentityProvider` values."
type IdentityProvidersConnection {
    "A list of edges which contains the `IdentityProvider` and cursor to aid in pagination."
    edges: [IdentityProvidersEdge!]!
    "A list of `IdentityProvider` objects."
    nodes: [IdentityProvider]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `IdentityProvider` you could get from the connection."
    totalCount: Int!
}

extend type Query {
    identityProviders(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
    ): IdentityProvidersConnection!

    identityProviderByDomain(domain: String!): IdentityProvider
    identityProviderByType  (type:   String!): IdentityProvider
}

input FacebookApplicationConfigurationInput {
    "This is an optional Application specific override for the top level appId."
    appId: String

    "This is an optional Application specific override for the top level button text."
    buttonText: String

    "This is an optional Application specific override for the top level client secret."
    client_secret: String

    "Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into."
    createRegistration: String

    "Determines if this identity provider is enabled for the Application specified by the applicationId key."
    enabled: Boolean

    "This is an optional Application specific override for for the top level fields."
    fields: String

    "This is an optional Application specific override for the top level permissions."
    permissions: String
}

input FacebookApplicationConfigurationsInput {
    applicationId: UUID
    config: FacebookApplicationConfigurationInput
}

input FacebookIdentityProviderInput {
    "The top-level Facebook appId for your Application. This value is retrieved from the Facebook developer website when you setup your Facebook developer account."
    appId: String

    "The configuration for each Application that the identity provider is enabled for."
    applicationConfiguration: [FacebookApplicationConfigurationsInput!]


    "The top-level button text to use on the FusionAuth login page for this Identity Provider."
    buttonText: String!

    "The top-level client secret to use with the Facebook Identity Provider when retrieving the long-lived token. This value is retrieved from the Facebook developer website when you setup your Facebook developer account."
    client_secret: String

    """Defaults to false. Determines if debug is enabled for this provider. When enabled, each time this provider is invoked to reconcile a login an Event Log will be created.

    This is useful for debugging purposes, but is not intended to be left on during production. It should be enabled during integration or if you are experiencing an issue with this identity provider.
"""
    debug: Boolean
    "Defaults to false. Determines if this provider is enabled. If it is false then it will be disabled globally."
    enabled: Boolean

    """ Defaults to email. The top-level fields that you are requesting from Facebook.

    Available Since 1.11.0
    The default value of email is now provided and stored in the database when this field is not specified. This is a required fields value for retrieving the user’s email address from the Facebook Graph API. Prior to this version, the value was defaulted at run-time."""
    fields: String

    """Defaults to email.  The top-level permissions that your application is asking of the user’s Facebook account.x

    Available Since 1.11.0
    The default value of email is now provided and stored in the database when this field is not specified. This is a required permissions value for the Facebook Login API to complete login. Prior to this version, the value not defaulted.
    """
    permissions: String

    "This field must be set to Facebook."
    type : String!
}

type FacebookApplicationConfiguration {
    "This is an optional Application specific override for the top level appId."
    appId: String!

    "This is an optional Application specific override for the top level button text."
    buttonText: String!

    "This is an optional Application specific override for the top level client secret."
    client_secret: String!

    "Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into."
    createRegistration: String!

    "Determines if this identity provider is enabled for the Application specified by the applicationId key."
    enabled: Boolean!

    "This is an optional Application specific override for for the top level fields."
    fields: String!

    "This is an optional Application specific override for the top level permissions."
    permissions: String!
}

type FacebookApplicationConfigurations {
    applicationId: UUID!
    application: Application
    config: FacebookApplicationConfiguration!
}

type FacebookIdentityProvider implements IdentityProvider{
    "The top-level Facebook appId for your Application. This value is retrieved from the Facebook developer website when you setup your Facebook developer account."
    appId: String!

    "The configuration for each Application that the identity provider is enabled for."
    applicationConfiguration: [FacebookApplicationConfigurations!]


    "The top-level button text to use on the FusionAuth login page for this Identity Provider."
    buttonText: String!

    "The top-level client secret to use with the Facebook Identity Provider when retrieving the long-lived token. This value is retrieved from the Facebook developer website when you setup your Facebook developer account."
    client_secret: String!

    """Defaults to false. Determines if debug is enabled for this provider. When enabled, each time this provider is invoked to reconcile a login an Event Log will be created.

    This is useful for debugging purposes, but is not intended to be left on during production. It should be enabled during integration or if you are experiencing an issue with this identity provider.
    """
    debug: Boolean!
    "Defaults to false. Determines if this provider is enabled. If it is false then it will be disabled globally."
    enabled: Boolean!

    """ Defaults to email. The top-level fields that you are requesting from Facebook.

    Available Since 1.11.0
    The default value of email is now provided and stored in the database when this field is not specified. This is a required fields value for retrieving the user’s email address from the Facebook Graph API. Prior to this version, the value was defaulted at run-time."""
    fields: String!

    "The id of the Facebook identity provider, which will always be 56abdcc7-8bd9-4321-9621-4e9bbebae494."
    id: UUID!

    "The name of the provider, this field will always be set to Facebook."
    name: String!

    """Defaults to email.  The top-level permissions that your application is asking of the user’s Facebook account.x

    Available Since 1.11.0
    The default value of email is now provided and stored in the database when this field is not specified. This is a required permissions value for the Facebook Login API to complete login. Prior to this version, the value not defaulted.
    """
    permissions: String!

    "This field must be set to Facebook."
    type : String!
}

extend type Mutation {
    createFacebookIdentityProvider(input: FacebookIdentityProviderInput) : FacebookIdentityProvider
    updateFacebookIdentityProvider(input: FacebookIdentityProviderInput) : FacebookIdentityProvider
    deleteFacebookIdentityProvider : Boolean

}

extend type Query {
    facebookIdentityProvider : FacebookIdentityProvider
}

input GoogleIdentityProviderConfigInput 
{
    "This is an optional Application specific override for the top level button text."
    buttonText: String

    "This is an optional Application specific override for the top level client id."
    client_id: String

    "This is an optional Application specific override for the top level client secret."
    client_secret: String

    "Defaults to true. Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into."
    createRegistration: Boolean 

    "Defaults to false. Determines if this identity provider is enabled for the Application specified by the applicationId key."
    enabled: Boolean 

    "This is an optional Application specific override for for the top level scope."
    scope: String

}

input GoogleIdentityProviderConfigsInput {
    applicationId: UUID!
    googleIdentityProviderConfig: GoogleIdentityProviderConfigInput!
}

input GoogleIdentityProviderInput {
    "The configuration for each Application that the identity provider is enabled for."
    applicationConfiguration: [GoogleIdentityProviderConfigsInput!]

    "The top-level button text to use on the FusionAuth login page for this Identity Provider."
    buttonText: String!

    "The top-level Google client id for your Application. This value is retrieved from the Google developer website when you setup your Google developer account."
    client_id: String!

    "The top-level client secret to use with the Google Identity Provider when retrieving the long-lived token. This value is retrieved from the Google developer website when you setup your Google developer account."
    client_secret: String!
    """Defaults to false.
    Determines if debug is enabled for this provider. When enabled, each time this provider is invoked to reconcile a login an Event Log will be created.

    This is useful for debugging purposes, but is not intended to be left on during production. It should be enabled during integration or if you are experiencing an issue with this identity provider."""
    debug: Boolean 
    
    "Defaults to false. Determines if this provider is enabled. If it is false then it will be disabled globally."
    enabled : Boolean

    "The top-level scope that you are requesting from Google."
    scope: String
    
    "This field must be set to Google"
    type: String!
}



type GoogleIdentityProviderConfig
{
    "This is an optional Application specific override for the top level button text."
    buttonText: String

    "This is an optional Application specific override for the top level client id."
    client_id: String

    "This is an optional Application specific override for the top level client secret."
    client_secret: String

    "Defaults to true. Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into."
    createRegistration: Boolean

    "Defaults to false. Determines if this identity provider is enabled for the Application specified by the applicationId key."
    enabled: Boolean

    "This is an optional Application specific override for for the top level scope."
    scope: String

}

type GoogleIdentityProviderConfigs {
    applicationId: UUID!
    googleIdentityProviderConfig: GoogleIdentityProviderConfig!
}

type GoogleIdentityProvider implements IdentityProvider{
    "The configuration for each Application that the identity provider is enabled for."
    applicationConfiguration: [GoogleIdentityProviderConfigs!]

    "The top-level button text to use on the FusionAuth login page for this Identity Provider."
    buttonText: String!

    "The top-level Google client id for your Application. This value is retrieved from the Google developer website when you setup your Google developer account."
    client_id: String!

    "The top-level client secret to use with the Google Identity Provider when retrieving the long-lived token. This value is retrieved from the Google developer website when you setup your Google developer account."
    client_secret: String!
    """Defaults to false.
    Determines if debug is enabled for this provider. When enabled, each time this provider is invoked to reconcile a login an Event Log will be created.

    This is useful for debugging purposes, but is not intended to be left on during production. It should be enabled during integration or if you are experiencing an issue with this identity provider."""
    debug: Boolean

    "Defaults to false. Determines if this provider is enabled. If it is false then it will be disabled globally."
    enabled : Boolean

    "The id of the Google identity provider, which will always be 82339786-3dff-42a6-aac6-1f1ceecb6c46."
    id: UUID!

    "The name of the provider, this field will always be set to Google."
    name: String!

    "The top-level scope that you are requesting from Google."
    scope: String

    "This field must be set to Google"
    type: String!
}


extend type Mutation {
    createGoogleIdentityProvider(input: GoogleIdentityProviderInput) : GoogleIdentityProvider
    updateGoogleIdentityProvider(input: GoogleIdentityProviderInput) : GoogleIdentityProvider
    deleteGoogleIdentityProvider : Boolean
}

extend type Query { googleIdentityProvider : GoogleIdentityProvider }


input HyprIdentityProviderConfigInput
{
    "Defaults to true. Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into."
    createRegistration: Boolean

    "Defaults to false. Determines if this identity provider is enabled for the Application specified by the applicationId key."
    enabled: Boolean

    "Defaults to false. This is an optional Application specific override for the top level licensingEnabled value."
    licensingEnabled: Boolean

    "Defaults to false. Determines if the licensing configuration provided in this application specific configuration should be used instead of the top level configuration. When this value is set to false the licensingEnabled and licensingURL in this application configuration will not be used."
    licensingEnabledOverride: Boolean

    "This is an optional Application specific override for the top level licensingURL value."
    licensingURL: String

    "This is an optional Application specific override for the top level relyingPartyApplicationId value."
    relyingPartyApplicationId: String

    "This is an optional Application specific override for the top level relyingPartyURL value."
    relyingPartyURL: String
}

input HyprIdentityProviderConfigsInput {
    applicationId: UUID!
    googleIdentityProviderConfig: HyprIdentityProviderConfigInput!
}

input HyprIdentityProviderInput {
    "The configuration for each Application that the identity provider is enabled for."
    applicationConfiguration: [HyprIdentityProviderConfigsInput!]

    """Defaults to false.
    Determines if debug is enabled for this provider. When enabled, each time this provider is invoked to reconcile a login an Event Log will be created.

    This is useful for debugging purposes, but is not intended to be left on during production. It should be enabled during integration or if you are experiencing an issue with this identity provider."""
    debug: Boolean

    "Defaults to false. Determines if this provider is enabled. If it is false then it will be disabled globally."
    enabled : Boolean

    "Defaults to false. Enable this if you are using the HYPR Mobile application from the app store, if you are using the HYPR SDK in your own application you should disable licensing."
    licensingEnabled: Boolean

    "The URL provided by HYPR that can provide license validation. When licensingEnabled is true this field is required."
    licensingURL: String

    "The Relying Party Application identifier provided to you by HYPR."
    relyingPartyApplicationId: String!

    "The Relying Party URL provided to you by HYPR."
    relyingPartyURL: String!

    "This field must be set to HYPR"
    type: String!
}



type HyprIdentityProviderConfig
{
    "Defaults to true. Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into."
    createRegistration: Boolean

    "Defaults to false. Determines if this identity provider is enabled for the Application specified by the applicationId key."
    enabled: Boolean

    "Defaults to false. This is an optional Application specific override for the top level licensingEnabled value."
    licensingEnabled: Boolean

    "Defaults to false. Determines if the licensing configuration provided in this application specific configuration should be used instead of the top level configuration. When this value is set to false the licensingEnabled and licensingURL in this application configuration will not be used."
    licensingEnabledOverride: Boolean

    "This is an optional Application specific override for the top level licensingURL value."
    licensingURL: String

    "This is an optional Application specific override for the top level relyingPartyApplicationId value."
    relyingPartyApplicationId: String

    "This is an optional Application specific override for the top level relyingPartyURL value."
    relyingPartyURL: String
}

type HyprIdentityProviderConfigs {
    applicationId: UUID!
    application: Application
    googleIdentityProviderConfig: HyprIdentityProviderConfig!
}

type HyprIdentityProvider implements IdentityProvider{
    "The configuration for each Application that the identity provider is enabled for."
    applicationConfiguration: [HyprIdentityProviderConfigs!]

    """Defaults to false.
    Determines if debug is enabled for this provider. When enabled, each time this provider is invoked to reconcile a login an Event Log will be created.

    This is useful for debugging purposes, but is not intended to be left on during production. It should be enabled during integration or if you are experiencing an issue with this identity provider."""
    debug: Boolean

    "Defaults to false. Determines if this provider is enabled. If it is false then it will be disabled globally."
    enabled : Boolean

    "The id of the HYPR identity provider, which will always be 778985b7-6fd8-414d-acf2-94f18fb7c7e0."
    id: UUID!

    "Defaults to false. Enable this if you are using the HYPR Mobile application from the app store, if you are using the HYPR SDK in your own application you should disable licensing."
    licensingEnabled: Boolean

    "The URL provided by HYPR that can provide license validation. When licensingEnabled is true this field is required."
    licensingURL: String

    "The name of the provider, this fill will always be set to HYPR"
    name: String!
    
    "The Relying Party Application identifier provided to you by HYPR."
    relyingPartyApplicationId: String!

    "The Relying Party URL provided to you by HYPR."
    relyingPartyURL: String!

    "This field must be set to HYPR"
    type: String!
}


extend type Mutation {
    createHyprIdentityProvider(input: HyprIdentityProviderInput) : HyprIdentityProvider
    updateHyprIdentityProvider(input: HyprIdentityProviderInput) : HyprIdentityProvider
    deleteHyprIdentityProvider : Boolean
}

extend type Query { hyprIdentityProvider : HyprIdentityProvider }

input TwitterIdentityProviderConfigInput
{
    "This is an optional Application specific override for the top level button text."
    buttonText: String

    "This is an optional Application specific override for the top level consumer key"
    consumerKey: String

    "This is an optional Application specific override for the top level consumer secret."
    consumerSecret: String

    "Defaults to true. Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into."
    createRegistration: Boolean

    "Defaults to false. Determines if this identity provider is enabled for the Application specified by the applicationId key."
    enabled: Boolean
}

input TwitterIdentityProviderConfigsInput {
    applicationId: UUID!
    twitterIdentityProviderConfig: TwitterIdentityProviderConfigInput!
}

input TwitterIdentityProviderInput {
    "The configuration for each Application that the identity provider is enabled for."
    applicationConfiguration: [TwitterIdentityProviderConfigsInput!]

    "The top-level button text to use on the FusionAuth login page for this Identity Provider."
    buttonText: String!


    "The top-level consumer key to use with the Twitter Identity Provider. This value is retrieved from the Twitter developer website when you setup your Twitter developer account."
    consumerKey: String!

    "The top-level consumer secret to use with the Twitter Identity Provider. This value is retrieved from the Twitter developer website when you setup your Twitter developer account."
    consumerSecret: String!

    """Defaults to false.
    Determines if debug is enabled for this provider. When enabled, each time this provider is invoked to reconcile a login an Event Log will be created.

    This is useful for debugging purposes, but is not intended to be left on during production. It should be enabled during integration or if you are experiencing an issue with this identity provider."""
    debug: Boolean

    "Defaults to false. Determines if this provider is enabled. If it is false then it will be disabled globally."
    enabled : Boolean

    "This field must be set to Twitter"
    type: String!
}



type TwitterIdentityProviderConfig
{
    "This is an optional Application specific override for the top level button text."
    buttonText: String

    "This is an optional Application specific override for the top level consumer key."
    consumerKey: String

    "This is an optional Application specific override for the top level consumer secret."
    consumerSecret: String

    "Defaults to true. Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into."
    createRegistration: Boolean

    "Defaults to false. Determines if this identity provider is enabled for the Application specified by the applicationId key."
    enabled: Boolean
}

type TwitterIdentityProviderConfigs {
    applicationId: UUID!
    application: Application
    twitterIdentityProviderConfig: TwitterIdentityProviderConfig!
}

type TwitterIdentityProvider implements IdentityProvider{
    "The configuration for each Application that the identity provider is enabled for."
    applicationConfiguration: [TwitterIdentityProviderConfigs!]

    "The top-level button text to use on the FusionAuth login page for this Identity Provider."
    buttonText: String!

    "The top-level consumer key to use with the Twitter Identity Provider. This value is retrieved from the Twitter developer website when you setup your Twitter developer account."
    consumerKey: String!

    "The top-level consumer secret to use with the Twitter Identity Provider. This value is retrieved from the Twitter developer website when you setup your Twitter developer account."
    consumerSecret: String!
    """Defaults to false.
    Determines if debug is enabled for this provider. When enabled, each time this provider is invoked to reconcile a login an Event Log will be created.

    This is useful for debugging purposes, but is not intended to be left on during production. It should be enabled during integration or if you are experiencing an issue with this identity provider."""
    debug: Boolean

    "Defaults to false. Determines if this provider is enabled. If it is false then it will be disabled globally."
    enabled : Boolean

    "The id of the Twitter identity provider, which will always be 82339786-3dff-42a6-aac6-1f1ceecb6c46."
    id: UUID!

    "The name of the provider, this field will always be set to Twitter."
    name: String!

    "This field must be set to Twitter"
    type: String!
}


extend type Mutation {
    createTwitterIdentityProvider(input: TwitterIdentityProviderInput) : TwitterIdentityProvider
    updateTwitterIdentityProvider(input: TwitterIdentityProviderInput) : TwitterIdentityProvider
    deleteTwitterIdentityProvider : Boolean
}

extend type Query { twitterIdentityProvider : TwitterIdentityProvider }


input Oauth2ConfigInput {
    "This is an optional Application specific override for the top level client id."
    client_id: String

    "This is an optional Application specific override for the top level client secret."
    client_secret: String

    "This is an optional Application specific override for for the top level scope."
    scope: String
}

input OpenIDIdentityProviderConfigInput
{
    "This is an optional Application specific override for the top level button text."
    buttonText: String

    oauth2: Oauth2ConfigInput

    "Defaults to true. Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into."
    createRegistration: Boolean

    "Defaults to false. Determines if this identity provider is enabled for the Application specified by the applicationId key."
    enabled: Boolean
}

input OpenIDIdentityProviderConfigsInput {
    applicationId: UUID!
    openIDIdentityProviderConfig: OpenIDIdentityProviderConfigInput!
}
enum ClientAuthenticationMethod {CLIENT_SECRET_BASIC, CLIENT_SECRET_POST, NONE}

input OAuth2Input {
    "The top-level authorization endpoint for the OpenID Connect identity provider. You can leave this blank if you provide the issuer field, which will be used to make a request to the OpenID Connect .well-known endpoint in order to dynamically resolve the authorization endpoint. If you provide an issuer then this field will be ignored."
    authorization_endpoint: String

    "The top-level client id for your Application."
    client_id: String!

    """The top-level client secret to use with the OpenID Connect identity provider.

    Required when clientAuthenticationMethod is client_secret_basic or client_secret_post."""
    client_secret: String

    "Defaults to client_secret_basic. The client authentication method to use with the OpenID Connect identity provider. Possible values are:"
    clientAuthenticationMethod: ClientAuthenticationMethod

    "The top-level issuer URI for the OpenID Connect identity provider. If this is provided, the authorization endpoint, token endpoint and userinfo endpoint will all be resolved using the issuer URI plus /.well-known/openid-configuration."
    issuer: String

    "The top-level scope that you are requesting from the OpenID Connect identity provider."
    scope: String

    "The top-level token endpoint for the OpenID Connect identity provider. You can leave this blank if you provide the issuer field, which will be used to make a request to the OpenID Connect .well-known endpoint in order to dynamically resolve the token endpoint. If you provide an issuer then this field will be ignored."
    token_endpoint: String

    "The top-level userinfo endpoint for the OpenID Connect identity provider. You can leave this blank if you provide the issuer field, which will be used to make a request to the OpenID Connect .well-known endpoint in order to dynamically resolve the userinfo endpoint. If you provide an issuer then this field will be ignored."
    userinfo_endpoint: String
}

input OpenIDIdentityProviderInput {
    "The configuration for each Application that the identity provider is enabled for."
    applicationConfiguration: [OpenIDIdentityProviderConfigsInput!]

    "The top-level button image (URL) to use on the FusionAuth login page for this Identity Provider."
    buttonImageURL: String

    "The top-level button text to use on the FusionAuth login page for this Identity Provider."
    buttonText: String!

    "The top-level OpenID client id for your Application. This value is retrieved from the OpenID developer website when you setup your OpenID developer account."
    client_id: String!

    "The top-level client secret to use with the OpenID Identity Provider when retrieving the long-lived token. This value is retrieved from the OpenID developer website when you setup your OpenID developer account."
    client_secret: String!
    """Defaults to false.
    Determines if debug is enabled for this provider. When enabled, each time this provider is invoked to reconcile a login an Event Log will be created.

    This is useful for debugging purposes, but is not intended to be left on during production. It should be enabled during integration or if you are experiencing an issue with this identity provider."""
    debug: Boolean

    "This is an optional list of domains that this OpenID Connect provider should be used for. This converts the FusionAuth login form to a domain-based login form. This type of form first asks the user for their email. FusionAuth then uses their email to determine if an OpenID Connect identity provider should be used. If an OpenID Connect provider should be used, the browser is redirected to the authorization endpoint of that identity provider. Otherwise, the password field is revealed on the form so that the user can login using FusionAuth."
    domains: [String!]

    "Defaults to false. Determines if this provider is enabled. If it is false then it will be disabled globally."
    enabled : Boolean

    "The unique Id of the lambda to used during the user reconcile process to map custom claims from the external identity provider to the FusionAuth user."
    lambdaConfiguration_reconcileId: UUID

    oauth2: OAuth2Input

    "This field must be set to OpenIDConnect"
    type: String!
}



type OpenIDIdentityProviderConfig
{
    "This is an optional Application specific override for the top level button image URL."
    buttonImageURL: String

    "This is an optional Application specific override for the top level button text."
    buttonText: String

    "This is an optional Application specific override for the top level client id."
    client_id: String

    "This is an optional Application specific override for the top level client secret."
    client_secret: String

    "Defaults to true. Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into."
    createRegistration: Boolean

    "Defaults to false. Determines if this identity provider is enabled for the Application specified by the applicationId key."
    enabled: Boolean

    "This is an optional Application specific override for for the top level scope."
    scope: String

}

type OpenIDIdentityProviderConfigs {
    applicationId: UUID!
    application: Application
    openIDIdentityProviderConfig: OpenIDIdentityProviderConfig!
}

type OAuth2 {
    "The top-level authorization endpoint for the OpenID Connect identity provider. You can leave this blank if you provide the issuer field, which will be used to make a request to the OpenID Connect .well-known endpoint in order to dynamically resolve the authorization endpoint. If you provide an issuer then this field will be ignored."
    authorization_endpoint: String

    "The top-level client id for your Application."
    client_id: String!

    "The top-level client secret to use with the OpenID Connect identity provider."
    client_secret: String

    "Defaults to client_secret_basic. The client authentication method to use with the OpenID Connect identity provider. Possible values are:"
    clientAuthenticationMethod: ClientAuthenticationMethod

    "The top-level issuer URI for the OpenID Connect identity provider. If this is provided, the authorization endpoint, token endpoint and userinfo endpoint will all be resolved using the issuer URI plus /.well-known/openid-configuration."
    issuer: String

    "The top-level scope that you are requesting from the OpenID Connect identity provider."
    scope: String

    "The top-level token endpoint for the OpenID Connect identity provider. You can leave this blank if you provide the issuer field, which will be used to make a request to the OpenID Connect .well-known endpoint in order to dynamically resolve the token endpoint. If you provide an issuer then this field will be ignored."
    token_endpoint: String

    "The top-level userinfo endpoint for the OpenID Connect identity provider. You can leave this blank if you provide the issuer field, which will be used to make a request to the OpenID Connect .well-known endpoint in order to dynamically resolve the userinfo endpoint. If you provide an issuer then this field will be ignored."
    userinfo_endpoint: String
}

type OpenIDIdentityProvider implements IdentityProvider{
    "The configuration for each Application that the identity provider is enabled for."
    applicationConfiguration: [OpenIDIdentityProviderConfigs!]

    "The top-level button image (URL) to use on the FusionAuth login page for this Identity Provider."
    buttonImageURL: String

    "The top-level button text to use on the FusionAuth login page for this Identity Provider."
    buttonText: String!

    "The top-level OpenID client id for your Application. This value is retrieved from the OpenID developer website when you setup your OpenID developer account."
    client_id: String!

    "The top-level client secret to use with the OpenID Identity Provider when retrieving the long-lived token. This value is retrieved from the OpenID developer website when you setup your OpenID developer account."
    client_secret: String!
    """Defaults to false.
    Determines if debug is enabled for this provider. When enabled, each time this provider is invoked to reconcile a login an Event Log will be created.

    This is useful for debugging purposes, but is not intended to be left on during production. It should be enabled during integration or if you are experiencing an issue with this identity provider."""
    debug: Boolean

    "This is an optional list of domains that this OpenID Connect provider should be used for. This converts the FusionAuth login form to a domain-based login form. This type of form first asks the user for their email. FusionAuth then uses their email to determine if an OpenID Connect identity provider should be used. If an OpenID Connect provider should be used, the browser is redirected to the authorization endpoint of that identity provider. Otherwise, the password field is revealed on the form so that the user can login using FusionAuth."
    domains: [String!]

    "Defaults to false. Determines if this provider is enabled. If it is false then it will be disabled globally."
    enabled : Boolean

    "The id of the OpenID identity provider, which will always be 82339786-3dff-42a6-aac6-1f1ceecb6c46."
    id: UUID!

    "The unique Id of the lambda to used during the user reconcile process to map custom claims from the external identity provider to the FusionAuth user."
    lambdaConfiguration_reconcileId: UUID

    "The name of the provider, this field will always be set to OpenID."
    name: String!

    oauth2: OAuth2

    "This field must be set to OpenID"
    type: String!
}


extend type Mutation {
    createOpenIDIdentityProvider(input: OpenIDIdentityProviderInput) : OpenIDIdentityProvider
    updateOpenIDIdentityProvider(input: OpenIDIdentityProviderInput) : OpenIDIdentityProvider
    deleteOpenIDIdentityProvider : Boolean
}

extend type Query { openIDIdentityProvider : OpenIDIdentityProvider }


input ExternalJWTIdentityProviderConfigInput
{
    "Defaults to true. Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into."
    createRegistration: Boolean

    "Defaults to false. Determines if this identity provider is enabled for the Application specified by the applicationId key."
    enabled: Boolean
}

input ExternalJWTIdentityProviderConfigsInput {
    applicationId: UUID!
    externalJWTIdentityProviderConfig: ExternalJWTIdentityProviderConfigInput!
}

input StringMapInput {
    key: String!
    value: String!
}

input OAuth2EndpointInput {
    "The authorization endpoint for this Identity Provider. This value is not utilized by FusionAuth is only provided to be returned by the Lookup Identity Provider API response. During integration you may then utilize this value to perform the browser redirect to the OAuth2 authorize endpoint."
    authorization_endpoint: String

    "The token endpoint for this Identity Provider. This value is not utilized by FusionAuth is only provided to be returned by the Lookup Identity Provider API response. During integration you may then utilize this value to complete the OAuth2 grant workflow."
    token_endpoint: String
}

input ExternalJWTIdentityProviderInput {
    "The configuration for each Application that the identity provider is enabled for."
    applicationConfiguration: [ExternalJWTIdentityProviderConfigsInput!]

    "A map of incoming claims to User fields, User data or Registration data. The key of the map is the incoming claim name from the configured identity provider. The following are allowed values:"
    claimMap: [StringMapInput!]

    """Defaults to false.
    Determines if debug is enabled for this provider. When enabled, each time this provider is invoked to reconcile a login an Event Log will be created.

    This is useful for debugging purposes, but is not intended to be left on during production. It should be enabled during integration or if you are experiencing an issue with this identity provider."""
    debug: Boolean

    "An array of domains that are managed by this Identity Provider."
    domains: [String!]

    "Defaults to false. Determines if this provider is enabled. If it is false then it will be disabled globally."
    enabled : Boolean

    "The name header claim that identifies the public key used to verify the signature. In most cases this be kid or x5t."
    headerKeyParameter: [String!]

    """A map of public keys used to verify JWT signatures issued from the configured Identity Provider. The key is the key identifier, this may be referred to as the kid or for X.509 certificates the x5t claim may be used.

    The map may contain one entry with an empty map key. When provided this key will be used when no header claim is provided to indicate which public key should be used to verify the signature. Generally speaking this will only be used when the Identity Provider issues JWTs without a key identifier in the header."""
    keys: [StringMapInput!]

    "The name of the Identity Provider."
    name: String

    oauth2: OAuth2EndpointInput

    "This field must be set to ExternalJWT"
    type: String!

    "The name of the claim that represents the unique identify of the User. This will generally be email or the name of the claim that provides the email address."
    uniqueIdentityClaim: String!
}

type StringMapEntry {
    key: String!
    value: String!
}


type ExternalJWTIdentityProviderConfig
{
    "Defaults to true. Determines if a UserRegistration is created for the User automatically or not. If a user doesn’t exist in FusionAuth and logs in through an identity provider, this boolean controls whether or not FusionAuth creates a registration for the User in the Application they are logging into."
    createRegistration: Boolean

    "Defaults to false. Determines if this identity provider is enabled for the Application specified by the applicationId key."
    enabled: Boolean
}

type ExternalJWTIdentityProviderConfigs {
    applicationId: UUID!
    application: Application
    externalJWTIdentityProviderConfig: ExternalJWTIdentityProviderConfig!
}

type OAuth2Endpoint {
    "The authorization endpoint for this Identity Provider. This value is not utilized by FusionAuth is only provided to be returned by the Lookup Identity Provider API response. During integration you may then utilize this value to perform the browser redirect to the OAuth2 authorize endpoint."
    authorization_endpoint: String

    "The token endpoint for this Identity Provider. This value is not utilized by FusionAuth is only provided to be returned by the Lookup Identity Provider API response. During integration you may then utilize this value to complete the OAuth2 grant workflow."
    token_endpoint: String

}

type ExternalJWTIdentityProvider implements IdentityProvider{
    "The configuration for each Application that the identity provider is enabled for."
    applicationConfiguration: [ExternalJWTIdentityProviderConfigs!]

    "A map of incoming claims to User fields, User data or Registration data. The key of the map is the incoming claim name from the configured identity provider. The following are allowed values:"
    claimMap: [StringMapEntry!]

    """Defaults to false.
    Determines if debug is enabled for this provider. When enabled, each time this provider is invoked to reconcile a login an Event Log will be created.

    This is useful for debugging purposes, but is not intended to be left on during production. It should be enabled during integration or if you are experiencing an issue with this identity provider."""
    debug: Boolean

    "An array of domains that are managed by this Identity Provider."
    domains: [String!]

    "Defaults to false. Determines if this provider is enabled. If it is false then it will be disabled globally."
    enabled : Boolean

    "The name header claim that identifies the public key used to verify the signature. In most cases this be kid or x5t."
    headerKeyParameter: [String!]

    "The unique identifier for the identity provider."
    id: UUID!

    """A map of public keys used to verify JWT signatures issued from the configured Identity Provider. The key is the key identifier, this may be referred to as the kid or for X.509 certificates the x5t claim may be used.

    The map may contain one entry with an empty map key. When provided this key will be used when no header claim is provided to indicate which public key should be used to verify the signature. Generally speaking this will only be used when the Identity Provider issues JWTs without a key identifier in the header."""
    keys: [StringMapEntry!]

    "The name of the Identity Provider."
    name: String

    oauth2: OAuth2Endpoint

    "This field must be set to ExternalJWT"
    type: String!

    "The name of the claim that represents the unique identify of the User. This will generally be email or the name of the claim that provides the email address."
    uniqueIdentityClaim: String!
}


extend type Mutation {
    createExternalJWTIdentityProvider(input: ExternalJWTIdentityProviderInput) : ExternalJWTIdentityProvider
    updateExternalJWTIdentityProvider(input: ExternalJWTIdentityProviderInput) : ExternalJWTIdentityProvider
    deleteExternalJWTIdentityProvider : Boolean
}

extend type Query { externalJWTIdentityProvider : ExternalJWTIdentityProvider }

type CleanSpeakIntegrationUsernameModeration {
    "The Id of the CleanSpeak Application where usernames are sent for moderation."
    applicationId: UUID!
    application: Application
    "True if CleanSpeak username moderation is enabled."
    enabled: Boolean!
}

type CleanSpeakIntegration {
    "The API key that is used when calling CleanSpeak for moderation."
    apiKey: String!

    "True if CleanSpeak integration is enabled."
    enabled: Boolean!

    "The URL of the CleanSpeak WebService service (i.e. http://localhost:8001/)."
    url: String!

    usernameModeration: CleanSpeakIntegrationUsernameModeration!
}

type KafkaIntgration {

    "The name of the Kafka topic to send messages."
    defaultTopic: String!

    "True if the Kafka integration is enabled."
    enabled: Boolean!

    "String key value pairs to be used when building the Kafka Producer."
    producer: [StringMapEntry!]
}

type TwilioIntegration {

    "The Twilio Account ID to use when connecting to the Twilio API. This can be found in your Twilio dashboard."
    accountSID: String!

    "The Twilio Auth Token to use when connecting to the Twilio API. This can be found in your Twilio dashboard."
    authToken: String!

    "True if the Twilio integration is enabled."
    enabled: Boolean!

    "The configured Twilio phone number that will be used to send messages. This can be found in your Twilio dashboard."
    fromPhoneNumber: String!

    """The Twilio message service Id, this is used when using Twilio Copilot to load balance between numbers. This can be found in your Twilio dashboard.

    When using the Twilio Messaging Services Id, you may omit the fromPhoneNumber field."""
    messagingServiceSid: String!
}

type Integration {
    cleanspeak: CleanSpeakIntegration
    kafka: KafkaIntgration
    twilio: TwilioIntegration
}

extend type Query {
    integration: Integration
}

input CleanSpeakIntegrationUsernameModerationInput {
    "The Id of the CleanSpeak Application where usernames are sent for moderation."
    applicationId: UUID

    "True if CleanSpeak username moderation is enabled."
    enabled: Boolean
}

input CleanSpeakIntegrationInput {
    "The API key that is used when calling CleanSpeak for moderation."
    apiKey: String

    "True if CleanSpeak integration is enabled."
    enabled: Boolean

    "The URL of the CleanSpeak WebService service (i.e. http://localhost:8001/)."
    url: String

    usernameModeration: CleanSpeakIntegrationUsernameModerationInput!
}

input KafkaIntgrationInput {

    "The name of the Kafka topic to send messages."
    defaultTopic: String

    "True if the Kafka integration is enabled."
    enabled: Boolean

    "String key value pairs to be used when building the Kafka Producer."
    producer: [StringMapInput!]
}

input TwilioIntegrationInput {

    "The Twilio Account ID to use when connecting to the Twilio API. This can be found in your Twilio dashboard."
    accountSID: String

    "The Twilio Auth Token to use when connecting to the Twilio API. This can be found in your Twilio dashboard."
    authToken: String

    "True if the Twilio integration is enabled."
    enabled: Boolean

    "The configured Twilio phone number that will be used to send messages. This can be found in your Twilio dashboard."
    fromPhoneNumber: String

    """The Twilio message service Id, this is used when using Twilio Copilot to load balance between numbers. This can be found in your Twilio dashboard.

    When using the Twilio Messaging Services Id, you may omit the fromPhoneNumber field."""
    messagingServiceSid: String
}

input IntegrationInput {
    cleanspeak: CleanSpeakIntegrationInput
    kafka: KafkaIntgrationInput
    twilio: TwilioIntegrationInput
}

extend type Mutation {
    updateIntegrations(integrations: IntegrationInput) : Integration
}

type IssuedJwt {
    token: String!
    refreshToken: String!
}

enum DeviceType {
    BROWSER,
    DESKTOP,
    LAPTOP,
    MOBILE,
    OTHER,
    SERVER
    TABLET,
    TV,
    UNKNOWN
}

input DeviceMetaDataInput {
    "A human readable description of the device represented by the device parameter."
    description: String

    "The IP address of this login request."
    lastAccessedAddress: String

    "A human readable name of the device represented by the device parameter."
    name: String

    "The type of device represented by the device parameter."
    type: DeviceType
}

input MetaDataInput {device: DeviceMetaDataInput}

type ReconciledJwt {
    "The refresh token that can be used to obtain a new access token once the provide one has expired."
    refreshToken: String!

    "If authenticated using a One Time Password and state was provided during the Change Password request this value will be returned exactly as it was provided."
    state: JSON

    "The access token, this string is an encoded JSON Web Token (JWT)."
    token: String!

    user: User
}

type PublicKey {
    kid: String!
    key: String!

}

"A `PublicKey` edge in the connection."
type PublicKeysEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `PublicKey` at the end of the edge."
    node: PublicKey
}

"A connection to a list of `PublicKey` values."
type PublicKeysConnection {
    "A list of edges which contains the `PublicKey` and cursor to aid in pagination."
    edges: [PublicKeysEdge!]!
    "A list of `PublicKey` objects."
    nodes: [PublicKey]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `PublicKey` you could get from the connection."
    totalCount: Int!
}


type DeviceMetaData {
    "A human readable description of the device represented by the device parameter."
    description: String!

    "The IP address of this login request."
    lastAccessedAddress: String!

    "A human readable name of the device represented by the device parameter."
    name: String!

    "The type of device represented by the device parameter."
    type: DeviceType!
}


type MetaData {
    device: DeviceMetaData!
}

type RefreshToken {
    "The Id of the Application for which this token is authorized to be exchanged for a new Access Token."
    applicationId: UUID!
    application: Application
    "The instant this Refresh Token was issued."
    insertInstant: Int!

    metaData: MetaData!
    "The string representation of the encoded Refresh Token. This value should be kept in some sort of secure storage and treated as sensitive information."
    token: String!

    "The User Id of the user for which this Refresh Token was issued."
    userId: User
}


extend type Mutation {
    """This API is used to issue a new access token (JWT) using an existing access token (JWT).

    This API provides the single signon mechanism for access tokens. For example you have an access token for application A and you need an access token for application B. You may use this API to request an access token to application B with the authorized token to application A. The returned access token will have the same expiration of the one provided.

    This API will use a JWT as authentication. See JWT Authentication for examples of how you can send the JWT to FusionAuth."""
    issueJwt(
        "The Id of the application for which authorization is being requested."
        applicationId: UUID!,
        """An existing refresh token used to request a refresh token in addition to a JWT in the response. If the cookie refresh_token is also on the request it will take precedence over this value.

        The target application represented by the applicationid request parameter must have refresh tokens enabled in order to receive a refresh token in the response."""
        refreshToken: String) : IssuedJwt

    "The Reconcile API is used to take a JWT issued by a third party identity provider as described by an Identity Provider configuration and reconcile the User represented by the JWT to FusionAuth."
    reconcileJwt(
        "The Id of the Application the User will be logged into during the reconcile process. If the User is not already registered to this Application they will be registered and be assigned any roles identified as default."
        applicationId: UUID!,
        "The encoded JWT issued by a third party Identity Provider.:"
        token: String!,
        "The unique Id of the Identity Provider to utilize when reconciling the JWT."
        identityProviderId: UUID!,
        "The IP address of the end-user that is logging into FusionAuth. If this value is omitted FusionAuth will attempt to obtain the IP address of the client, the value will be that of the X-Forwarded-For header if provided or the last proxy that sent the request. The IP address will be stored in the User login history."
        ipAddress: String,
        metaData: MetaDataInput) : ReconciledJwt

    refreshJwt(
        "The refresh token to be used to obtain a new access token."
        refreshToken: String,
        "The previously issued encoded access token. When provided on the request, this value will be relayed in the related JWT Refresh webhook event within the original field."
        token: String) : String

    refreshToken: [RefreshToken!]

    validateJwt(token: String) : JSON
}

extend type Query {


    publicKey(kid: String!) : PublicKey
    publicKeyByApp(
        """The Application Id is used to retrieve a specific Public Key. This will return the Public Key that has been specifically configured for the provided Application to sign the access token.

    A public key may not be available for an Application if it is configured to use the global JWT configuration or a HMAC is the configured algorithm for JWT signing."""
        applicationId: UUID!
    ) : PublicKey

    publicKeys(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,

        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int
    ): PublicKeysConnection!
}

extend type Application
{
    publicKey: PublicKey
}

extend type Mutation {
    revokeApplicationRefreshTokens(applicationId: UUID!) : Boolean
    revokeUserRefreshTokens(userId: UUID!) : Boolean
    revokeRefreshTokens(token: String!) : Boolean
}

"The key type."
enum KeyType {
    EC,
    RSA,
    HMAC
}

"The algorithm used to encrypt the Key."
enum KeyAlgorithm
{
    "ECDSA using P-256 curve and SHA-256 hash algorithm" ES256
    "ECDSA using P-384 curve and SHA-384 hash algorithm" ES384
    "ECDSA using P-521 curve and SHA-512 hash algorithm" ES512
    "RSA using SHA-256 hash algorithm" RS256
    "RSA using SHA-384 hash algorithm" RS384
    "RSA using SHA-512 hash algorithm" RS512
    "HMAC using SHA-256 hash algorithm" HS256
    "HMAC using SHA-384 hash algorithm" HS384
    "HMAC using SHA-512 hash algorithm" HS512
}

type CertificateInformation {
    "The issuer of the RSA or EC certificate. This field is omitted for HMAC key types."
    issuer: String!

    "The md5 fingerprint of the RSA or EC certificate. This field is omitted for HMAC key types."
    md5Fingerprint: String!

    "The serial number of the RSA or EC certificate. This field is omitted for HMAC key types."
    serialNumber: String!

    "The SHA-1 fingerprint of the RSA or EC certificate. This field is omitted for HMAC key types."
    sha1Fingerprint: String!

    "The SHA-1 thumbprint of the RSA or EC certificate. This field is omitted for HMAC key types."
    sha1Thumbprint: String!

    "The SHA-256 fingerprint of the RSA or EC certificate. This field is omitted for HMAC key types."
    sha256Fingerprint: String!

    "The SHA-256 thumbprint of the RSA or EC certificate. This field is omitted for HMAC key types."
    sha256Thumbprint: String!

    "The subject of the RSA or EC certificate. This field is omitted for HMAC key types."
    subject: String!

    "The UNIX time in milliseconds marking the start of the RSA or EC certificate validity period. This field is omitted for HMAC key types."
    validFrom: Int!

    "The UNIX time in milliseconds marking the expiration RSA or EC certificate. This field is omitted for HMAC key types."
    validTo: Int!
}


interface Key {
    "The algorithm used to encrypt the key."
    algorithm: KeyAlgorithm

    "The Id of the Key."
    id: UUID!

    "The instant that the key was added to the FusionAuth database."
    insertInstant: Int!

    "The key identifier 'kid'."
    kid: String!

    "The name of the key."
    name: String!
}


type HMACKey  implements Key {
    "The algorithm used to encrypt the key."
    algorithm: KeyAlgorithm

    "The Id of the Key."
    id: UUID!

    "The instant that the key was added to the FusionAuth database."
    insertInstant: Int!

    "The key identifier 'kid'."
    kid: String!

    "The name of the key."
    name: String!
}

type RSAKey implements Key {
    "The algorithm used to encrypt the key."
    algorithm: KeyAlgorithm

    "The RSA certificate."
    certificate: String

    "The RSA certificate information."
    certificateInformation : CertificateInformation

    "The instant marking the expiration RSA certificate."
    expirationInstant: Int!

    "The Id of the Key."
    id: UUID!

    "The instant that the key was added to the FusionAuth database."
    insertInstant: Int!

    "The issuer of the RSA certificate."
    issuer: String!

    "The key identifier 'kid'."
    kid: String!

    "The length of the RSA certificate. "
    length: String!

    "The name of the key."
    name: String!

    "The RSA certificate public key."
    publicKey: String!

    "The key type. The possible values are:"
    type: KeyType!
}

type ECKey implements Key {
    "The algorithm used to encrypt the key."
    algorithm: KeyAlgorithm

    "The RSA certificate."
    certificate: String

    "The RSA certificate information."
    certificateInformation : CertificateInformation

    "The instant marking the expiration RSA certificate."
    expirationInstant: Int!

    "The Id of the Key."
    id: UUID!

    "The instant that the key was added to the FusionAuth database."
    insertInstant: Int!

    "The issuer of the RSA certificate."
    issuer: String!

    "The key identifier 'kid'."
    kid: String!

    "The length of the RSA certificate. "
    length: String!

    "The name of the key."
    name: String!

    "The RSA certificate public key."
    publicKey: String!

    "The key type. The possible values are:"
    type: KeyType!
}

"A `Key` edge in the connection."
type KeysEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Key` at the end of the edge."
    node: Key
}

"A connection to a list of `Key` values."
type KeysConnection {
    "A list of edges which contains the `Key` and cursor to aid in pagination."
    edges: [KeysEdge!]!
    "A list of `Key` objects."
    nodes: [Key]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Key` you could get from the connection."
    totalCount: Int!
}

input KeyCondition {
    "Filter by Key Algorithm"
    algorithm: [KeyAlgorithm!]
    "Filter by Issuer"
    issuer: [String!]
    "Filter by key type"
    type: [KeyType!]
}

enum KeysOrderBy {
    INSERT_INSTANT_ASC,
    INSERT_INSTANT_DESC,
    EXPIRATION_INSTANT_ASC,
    EXPIRATION_INSTANT_DESC,
    ISSUER_ASC,
    ISSUER_DESC,
    NAME_ASC,
    NAME_DESC
}

extend type Query {
    key(keyId: UUID!) : Key
    keys(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: KeyCondition,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Key`."
        orderBy: [KeysOrderBy!]
        ) : KeysConnection!
}

input KeyImportInput {
    "The algorithm used to encrypt the Key. The algorithm will be inferred if it is not passed explicitly. The following values represent algorithms supported by FusionAuth:"
    algorithm: KeyAlgorithm

    "The certificate to import. The publicKey will be extracted from the certificate."
    certificate: String

    "The Key identifier 'kid'."
    kid: String

    "The name of the Key."
    name: String!

    "The Key public key. Required if importing an RSA or EC key and a certificate is not provided."
    publicKey: String

    "The Key private key. Optional if importing an RSA or EC key. If the key is only to be used for token validation, only a public key is necessary and this field may be omitted."
    privateKey: String
    "The Key secret. This field is required if importing an HMAC key type."
    secret: String

    "The Key type. This field is required if importing an HMAC key type, or if importing a public key / private key pair."
    type: KeyType
}

extend type Mutation {
    "Delete the Key with the given Id"
    deleteKey(keyId: UUID!) : Boolean

    "Generate a new Key"
    generateKey(keyId: UUID, algorithm: KeyAlgorithm!, name: String!, length: Int) : Key

    " Import an existing Key"
    importKey(keyId: UUID, input: KeyImportInput!) : Key
}

enum LambdaType {
    JWTPopulate
    OpenIDReconcile
    SAMLv2Reconcile
    SAMLv2Populate
}

input LambdaInput {
    "The lambda function body, a JavaScript function."
    body: String!

    "Defaults to false. Whether or not debug event logging is enabled for this Lambda."
    debug: Boolean

    "Defaults to true. Whether or not this Lambda is enabled."
    enabled: Boolean

    "The name of the lambda."
    name: String!

    "The lambda type."
    type : LambdaType!
}

type Lambda {
    "The lambda function body, a JavaScript function."
    body: String!

    "Defaults to false. Whether or not debug event logging is enabled for this Lambda."
    debug: Boolean

    "Defaults to true. Whether or not this Lambda is enabled."
    enabled: Boolean

    "The Id of the Lambda."
    id: UUID!

    "The instant that the lambda created."
    insertInstant: Int!
    "The name of the lambda."
    name: String!

    "The lambda type."
    type : LambdaType!
}

"A `Lambda` edge in the connection."
type LambdasEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Lambda` at the end of the edge."
    node: Lambda
}

"A connection to a list of `Lambda` values."
type LambdasConnection {
    "A list of edges which contains the `Lambda` and cursor to aid in pagination."
    edges: [LambdasEdge!]!
    "A list of `Lambda` objects."
    nodes: [Lambda]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Lambda` you could get from the connection."
    totalCount: Int!
}

input LambdaCondition {
    "The type of Lambdas to retrieve."
    type : LambdaType!
    "Filter by debug."
    debug: Boolean

    "Filter by enabled."
    enabled: Boolean
}

enum LambdasOrderBy {
    INSERT_INSTANT_ASC,
    INSERT_INSTANT_DESC
}

extend type Mutation {
    createLambda(
        "The Id to use for the new Lambda. If not specified a secure random UUID will be generated."
        lambdaId: UUID,
        input: LambdaInput) : Lambda

    lambda(lambdaId: UUID!) : Lambda
    "Reads and enables pagination through a set of `Lambda`."
    lambdas(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: LambdaCondition,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Lambda`."
        orderBy: [LambdasOrderBy!]
    ): LambdasConnection!

    updateLambda(
        "This API is used to update an existing Lambda. The lambda type may not be changed."
        lambdaId: UUID!,
        input: LambdaInput) : Lambda

    deleteLambda(
        "The unique Id of the Lambda to delete."
        lambdaId: UUID!) : Lambda
}

type LoginResponse {
    "The refresh token that can be used to obtain a new access token once the provide one has expired."
    refreshToken: String

    "If authenticated using a One Time Password and state was provided during the Change Password request this value will be returned exactly as it was provided."
    state: JSON

    "The Two Factor Trust identifier. This value is returned when trustComputer was set to true on the request. This value can be used by subsequent login requests to bypass the Two Factor challenge."
    twoFactorTrustId: String

    "The access token, this string is an encoded JSON Web Token (JWT)."
    token: String!
    user: User!
}

extend type Mutation {
    login(
        "The Id of the Application the user is to be logged into. If this parameter is omitted the user will still be authenticated but a login count will not be recorded for an Application."
        applicationId: UUID,

        "The IP address of the end-user that is logging into FusionAuth. If this value is omitted FusionAuth will attempt to obtain the IP address of the client, the value will be that of the X-Forwarded-For header if provided or the last proxy that sent the request. The IP address will be stored in the User login history."
        ipAddress: String

        "The login identifier of the user. The login identifier can be either the email or the username."
        loginId: String!

        "This meta data is used to describe the refresh token that may be generated for this login request."
        metaData: MetaDataInput

        """Defaults to false. When this value is set to true a JWT will not be issued as part of this request. The response body will not contain the token or refreshToken fields, and the access_token and refresh_token cookies will not be written to the HTTP response.

        This optional parameter may be helpful when performing high volume authentication requests and the JWT is not being utilized, in this scenario removing the additional latency required to issue and sign the JWT may have a measurable cumulative effect on performance.
        """
        noJWT: Boolean
        "The user’s password or an Application specific Authentication Token."
        password: String!

        "The Two Factor Trust identifier returned by the Two Factor Login API response. This value be may be provided to bypass the Two Factor challenge when a User has Two Factor enabled."
        twoFactorTrustId: String
    ) : LoginResponse

    loginWithOneTimePassword(
        "The Id of the Application the user is to be logged into. If this parameter is omitted the user will still be authenticated but a login count will not be recorded for an Application."
        applicationId: UUID,

        "The IP address of the end-user that is logging into FusionAuth. If this value is omitted FusionAuth will attempt to obtain the IP address of the client, the value will be that of the X-Forwarded-For header if provided or the last proxy that sent the request. The IP address will be stored in the User login history."
        ipAddress: String

        "This meta data is used to describe the refresh token that may be generated for this login request."
        metaData: MetaDataInput

        """Defaults to false. When this value is set to true a JWT will not be issued as part of this request. The response body will not contain the token or refreshToken fields, and the access_token and refresh_token cookies will not be written to the HTTP response.

        This optional parameter may be helpful when performing high volume authentication requests and the JWT is not being utilized, in this scenario removing the additional latency required to issue and sign the JWT may have a measurable cumulative effect on performance.
        """
        noJWT: Boolean
        "The one time password returned by the Change Password API. This value takes the place of the loginId and the password fields."
        oneTimePassword: String!

        "The Two Factor Trust identifier returned by the Two Factor Login API response. This value be may be provided to bypass the Two Factor challenge when a User has Two Factor enabled."
        twoFactorTrustId: String
    ) : LoginResponse

    twoFactorLogin(
        "The Id of the Application the user is to be logged into. If this parameter is omitted the user will still be authenticated but a login count will not be recorded for an Application."
        applicationId: UUID,

        "The time based one time use password, also called a Two Factor verification code."
        code: String!

        "The IP address of the end-user that is logging into FusionAuth. If this value is omitted FusionAuth will attempt to obtain the IP address of the client, the value will be that of the X-Forwarded-For header if provided or the last proxy that sent the request. The IP address will be stored in the User login history."
        ipAddress: String

        "This meta data is used to describe the refresh token that may be generated for this login request."
        metaData: MetaDataInput

        """Defaults to false. When this value is set to true a JWT will not be issued as part of this request. The response body will not contain the token or refreshToken fields, and the access_token and refresh_token cookies will not be written to the HTTP response.

        This optional parameter may be helpful when performing high volume authentication requests and the JWT is not being utilized, in this scenario removing the additional latency required to issue and sign the JWT may have a measurable cumulative effect on performance.
        """
        noJWT: Boolean

        "Defaults to false. When this value is set to true the response will contain a Two Factor Trust identifier. This can be used on subsequent Login requests to allow the Two Factor challenge to be bypassed."
        trustComputer: Boolean

        "The one time password returned by the Change Password API. This value takes the place of the loginId and the password fields."
        oneTimePassword: String!

        "The Two Factor Trust identifier returned by the Two Factor Login API response. This value be may be provided to bypass the Two Factor challenge when a User has Two Factor enabled."
        twoFactorTrustId: String
    ) : LoginResponse

    updateLoginInstance(userId: UUID, applicationId:UUID, ipAddress: String) : Boolean

}

type LoginRecord {
    "The unique Id of the application."
    applicationId: UUID!

    "The name of the application. Because the application name may be modified after the login event occurred, only the applicationId should be considered immutable for historical purposes when identifying the application."
    applicationName: String!

    "The email or username of the user. Because email or username may be modified after the login event occurred, only the userId and the should be considered immutable for historical purposes when identifying the user."
    loginId: String!

    "The instant when the login occurred."
    instant: Int!

    "The recorded IP address for this login record."
    ipAddress: String!

    "The unique Id of the user."
    userId: UUID!
}

"A `LoginRecord` edge in the connection."
type SearchLoginRecordsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `LoginRecord` at the end of the edge."
    node: LoginRecord
}

"A connection to a list of `LoginRecord` values."
type SearchLoginRecordsConnection {
    "A list of edges which contains the `LoginRecord` and cursor to aid in pagination."
    edges: [SearchLoginRecordsEdge!]!
    "A list of `LoginRecord` objects."
    nodes: [LoginRecord]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `LoginRecord` you could get from the connection."
    totalCount: Int!
}

input SearchLoginRecordsCondition {
    "The unique Id of the Application used to narrow the search results to logins for a particular application."
    applicationId: UUID

    "The end instant of the date/time range to search within."
    end: Int

    """The start instant of the date/time range to search within.

    The offset into the total results. In order to paginate the results, increment this value by the numberOfResults for subsequent requests."""
    start: Int

    "The unique Id of the User used to narrow the search results to login records for a particular user."
    userId: UUID
}

enum SearchLoginRecordsOrderBy {
    INSERT_INSTANT_ASC,
    INSERT_INSTANT_DESC
}

extend type Query {
    "Reads and enables pagination through a set of `Theme`."
    searchLoginRecord(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: SearchLoginRecordsCondition,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Theme`."
        orderBy: [SearchLoginRecordsOrderBy!]
    ): SearchLoginRecordsConnection!
}

extend type User {
    "Reads and enables pagination through a set of `Theme`."
    searchLoginRecords(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: SearchLoginRecordsCondition,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Theme`."
        orderBy: [SearchLoginRecordsOrderBy!]
    ): SearchLoginRecordsConnection!
}

extend type Application {
    "Reads and enables pagination through a set of `Theme`."
    searchLoginRecords(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "A condition to be used in determining which values should be returned by the collection."
        condition: SearchLoginRecordsCondition,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
        "The method to use when ordering `Theme`."
        orderBy: [SearchLoginRecordsOrderBy!]
    ): SearchLoginRecordsConnection!
}


type Passwordless {
    "The unique code used to complete the login request."
    code: String
}

extend type Mutation {
    "Generate a passwordless login code"
    startPasswordless(
        "The unique Id of the application you are requesting to log into."
        applicationId: String!,
        "The login identifier of the user. The login identifier can be either the email or the username."
        loginId: String!,
        "An optional object that will be returned un-modified when you complete the passwordless login request. This may be useful to return the user to particular state once they complete login using the passwordless code."
        state: JSON
    ) : String

    "Generate a passwordless login code"
    sendPasswordless(
        "The unique Id of the application you are requesting to log into."
        applicationId: String!,
        "The login identifier of the user. The login identifier can be either the email or the username."
        loginId: String!,
        "An optional object that will be returned un-modified when you complete the passwordless login request. This may be useful to return the user to particular state once they complete login using the passwordless code."
        state: JSON
    ) : Boolean

    "Generate a code and send a login link via email"
    sendPasswordlessCode(
        "The unique code to send via email, used to complete the login request. This value can be generated with a call to the Start Passwordless Login API."
        code: String!) : Boolean

    loginPasswordLess(
        "The Id of the Application the user is to be logged into. If this parameter is omitted the user will still be authenticated but a login count will not be recorded for an Application."
        code: String!,

        "The IP address of the end-user that is logging into FusionAuth. If this value is omitted FusionAuth will attempt to obtain the IP address of the client, the value will be that of the X-Forwarded-For header if provided or the last proxy that sent the request. The IP address will be stored in the User login history."
        ipAddress: String

        "This meta data is used to describe the refresh token that may be generated for this login request."
        metaData: MetaDataInput

        """Defaults to false. When this value is set to true a JWT will not be issued as part of this request. The response body will not contain the token or refreshToken fields, and the access_token and refresh_token cookies will not be written to the HTTP response.

        This optional parameter may be helpful when performing high volume authentication requests and the JWT is not being utilized, in this scenario removing the additional latency required to issue and sign the JWT may have a measurable cumulative effect on performance.
        """
        noJWT: Boolean

        "The Two Factor Trust identifier returned by the Two Factor Login API response. This value be may be provided to bypass the Two Factor challenge when a User has Two Factor enabled."
        twoFactorTrustId: String
    ) : LoginResponse
}

input RegistrationInput {
    "The Id of the Application that this registration is for."
    applicationId: UUID!

    "An object that can hold any information about the User for this registration that should be persisted."
    data: JSON

    "An array of locale strings that give, in order, the User’s preferred languages for this registration. These are important for email templates and other localizable text. See Locales."
    preferredLanguages: [Locale!]

    "The Id of this registration. If this is not specified, FusionAuth will create a random UUID for you."
    id: UUID

    "The list of roles that the User has for this Application."
    roles: [String!]

    """The User’s preferred timezone for this Application registration. The format is not enforced, however it is recommended to use a timezone in the TZ format such as

    America/Denver or US/Mountain"""
    timezone: String

    "The username of the User for this Application only."
    username: String
}

type RegistrationResponse {
    registration: UserRegistration!

    "The access token, this string is an encoded JSON Web Token (JWT)."
    token: String!

    "User info, available when user was also created"
    user: User
}

extend type Mutation {
    "Create a User Registration for an existing User"
    registerExistingUser("The Id of the User that is registering for the Application." userId: UUID!,
        "Determines if FusionAuth should generate an Authentication Token for this registration."
        generateAuthenticationToken : Boolean,
        registration: RegistrationInput!,
        "Indicates to FusionAuth that it should skip registration verification even if it is enabled for the Application."
        skipRegistrationVerification: Boolean) : RegistrationResponse

    registerAndCreateUser(
        "The Id to use for the new User. If you don’t specify this, FusionAuth will generate a random UUID."
        userId: UUID,
        "Determines if FusionAuth should generate an Authentication Token for this registration."
        generateAuthenticationToken : Boolean,
        registration: RegistrationInput!,
        """ Defaults to false. Whether or not the User is sent an email asking them to setup their password. This is useful if someone else is creating an account for a User with an Application.

        The Email Template that is used is configured in the System Configuration setting for Set Password Email Template.

        If you have also enabled email verification and do not select to skip verification using the skipVerification parameter, only the setup password email will be sent to the user. Setting up the password using the email sent during this user create operation will implicitly verify the User’s email if it is not already verified.

        If the SMTP email configuration is not complete, or disabled, this value is ignored.
"""
        sendSetPasswordEmail: Boolean,

        "Defaults to false. Indicates to FusionAuth that it should skip registration verification even if it is enabled for the Application."
        skipRegistrationVerification: Boolean

        "Defaults to false. Whether or not email verification should be skipped or not. In some cases, you might want to verify User’s emails and in other cases you won’t. This flag controls that behavior."
        skipVerification: Boolean,
        user: UserInput) : RegistrationResponse

    updateRegistration(
        "The Id of the User that is updating their User Registration for the Application."
        userId: UUID!,
        "Determines if FusionAuth should generate an Authentication Token for this registration."
        generateAuthenticationToken : Boolean,
        registration: RegistrationInput!
    ) : RegistrationResponse
}

extend type Query {
    registration(applicationId: UUID!, userId:UUID!) : RegistrationResponse
}
extend type Mutation {
    deleteRegistration(applicationId: UUID!, userId:UUID!) : Boolean

    verifyRegistration(
        "The verification Id generated by FusionAuth used to verify the User’s registration is valid by ensuring they have access to the provided email address"
        verificationId: UUID!) : Boolean

    resendVerificationEmail(
        "The unique Id of the Application for this User registration."
        applicationId: UUID!,

        "The email address used to uniquely identify the User."
        email: String!,

        "If you would only like to generate a new verificationId and return it in the JSON body without FusionAuth attempting to send the User an email set this optional parameter to false."
        sendVerifyRegistrationEmail: Boolean): String
}

extend type Application {
    resendVerificationEmail(
        "The email address used to uniquely identify the User."
        email: String!,

        "If you would only like to generate a new verificationId and return it in the JSON body without FusionAuth attempting to send the User an email set this optional parameter to false."
        sendVerifyRegistrationEmail: Boolean): String
}

type ActiveUser {
    "The interval for this count."
    interval: Int!

    "The number of daily active users for this count."
    count: Int!
}

"A `ActiveUser` edge in the connection."
type ActiveUsersEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `ActiveUser` at the end of the edge."
    node: ActiveUser
}

"A connection to a list of `ActiveUser` values."
type ActiveUsersConnection {
    "A list of edges which contains the `ActiveUser` and cursor to aid in pagination."
    edges: [ActiveUsersEdge!]!
    "A list of `ActiveUser` objects."
    nodes: [ActiveUser]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `ActiveUser` you could get from the connection."
    totalCount: Int!
}

type ApplicationTotal {
    "Application ID"
    id: UUID!

    "The total number of logins (all time) for the Application."
    logins: Int!
    "The current number of registrations for the Application. This doesn’t include registrations for user’s that have been deleted from FusionAuth."
    registrations: Int!
    "The total number of registrations (all time) for the Application."
    totalRegistrations: Int!
}

type Totals {
    "A map where the key is the Id of the Application and the value is an object that contains the totals for that Application."
    applicationTotals: ApplicationTotal!
    application: Application

    "The current number of registered users. This value is incremented each time a new user is added to FusionAuth, and this value is decremented when a user is deleted from FusionAuth."
    globalRegistrations: Int

    "The total number of registrations (all time). When a user is removed from FusionAuth this number is not decremented"
    totalGlobalRegistrations: Int
}

extend type Query {
    dailyActiveUsers(
        "A specific application to query for. If not provided a \"Global\" (across all applications) daily active users report will be returned."
        applicationId: UUID,

        "The end of the query range. This is an instant but it is truncated to days in the report timezone (which is set in the system settings)."
        end: Int,
        "The start of the query range. This is an instant but it is truncated to days in the report timezone (which is set in the system settings)"
        start: Int,

        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int
    ) : ActiveUsersConnection!

    hourlyActiveUsers(
        "A specific application to query for. If not provided a \"Global\" (across all applications) daily active users report will be returned."
        applicationId: UUID,

        "The end of the query range. This is an instant but it is truncated to days in the report timezone (which is set in the system settings)."
        end: Int,
        "The start of the query range. This is an instant but it is truncated to days in the report timezone (which is set in the system settings)"
        start: Int,

        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,

        """When this parameter is provided it will reduce the scope of the report to a single user with the requested email or username specified by this parameter.

        This parameter is mutually exclusive with userId, if both are provided, the loginId will take precedence."""
        loginId: UUID,

        """When this parameter is provided it will reduce the scope of the report to a single user with the requested unique Id.

        This parameter is mutually exclusive with loginId, if both are provided, the loginId will take precedence."""
        userId: UUID
    ) : ActiveUsersConnection!

    monthlyActiveUsers(
        "A specific application to query for. If not provided a \"Global\" (across all applications) daily active users report will be returned."
        applicationId: UUID,

        "The end of the query range. This is an instant but it is truncated to days in the report timezone (which is set in the system settings)."
        end: Int,
        "The start of the query range. This is an instant but it is truncated to days in the report timezone (which is set in the system settings)"
        start: Int,

        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
    ) : ActiveUsersConnection!

    reportTotals: Totals
}

extend type Application {
    dailyActiveUsers(
        "The end of the query range. This is an instant but it is truncated to days in the report timezone (which is set in the system settings)."
        end: Int,
        "The start of the query range. This is an instant but it is truncated to days in the report timezone (which is set in the system settings)"
        start: Int,

        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int
    ) : ActiveUsersConnection!

    hourlyActiveUsers(
        "The end of the query range. This is an instant but it is truncated to days in the report timezone (which is set in the system settings)."
        end: Int,
        "The start of the query range. This is an instant but it is truncated to days in the report timezone (which is set in the system settings)"
        start: Int,

        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,

        """When this parameter is provided it will reduce the scope of the report to a single user with the requested email or username specified by this parameter.

        This parameter is mutually exclusive with userId, if both are provided, the loginId will take precedence."""
        loginId: UUID,

        """When this parameter is provided it will reduce the scope of the report to a single user with the requested unique Id.

        This parameter is mutually exclusive with loginId, if both are provided, the loginId will take precedence."""
        userId: UUID
    ) : ActiveUsersConnection!

    monthlyActiveUsers(

        "The end of the query range. This is an instant but it is truncated to days in the report timezone (which is set in the system settings)."
        end: Int,
        "The start of the query range. This is an instant but it is truncated to days in the report timezone (which is set in the system settings)"
        start: Int,

        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
    ) : ActiveUsersConnection!
}

extend type Login {

    hourlyActivity(
        "A specific application to query for. If not provided a \"Global\" (across all applications) daily active users report will be returned."
        applicationId: UUID,

        "The end of the query range. This is an instant but it is truncated to days in the report timezone (which is set in the system settings)."
        end: Int,
        "The start of the query range. This is an instant but it is truncated to days in the report timezone (which is set in the system settings)"
        start: Int,

        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int
    ) : ActiveUsersConnection!

}

extend type User {

    hourlyActivity(
        "A specific application to query for. If not provided a \"Global\" (across all applications) daily active users report will be returned."
        applicationId: UUID,

        "The end of the query range. This is an instant but it is truncated to days in the report timezone (which is set in the system settings)."
        end: Int,
        "The start of the query range. This is an instant but it is truncated to days in the report timezone (which is set in the system settings)"
        start: Int,

        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int
    ) : ActiveUsersConnection!

}

enum HttpMethod {GET POST PUT DELETE HEAD OPTIONS}


type ConfigurationDelete{
    "Whether or not FusionAuth should delete the Audit Log based upon this configuration. When true the auditLogConfiguration.delete.numberOfDaysToRetain will be used to identify audit logs that are eligible for deletion. When this value is set to false audit logs will be preserved forever."
    enabled: Boolean!
    "The number of days to retain the Audit Log."
    numberOfDaysToRetain: Int!
}

type ConfigurationDeletable {delete : ConfigurationDelete!}

type CorsConfiguration {
    "The Access-Control-Allow-Credentials response header values as described by MDN Access-Control-Allow-Credentials."
    allowCredentials: Boolean

    "The Access-Control-Allow-Headers response header values as described by MDN Access-Control-Allow-Headers."
    allowedHeaders: [String!]

    "The Access-Control-Allow-Methods response header values as described by MDN Access-Control-Allow-Methods."
    allowedMethods: [HttpMethod!]

    "The Access-Control-Allow-Origin response header values as described by MDN Access-Control-Allow-Origin. If the wildcard * is specified, no additional domains may be specified."
    allowedOrigins: [String!]

    "Whether the FusionAuth CORS filter will process requests made to FusionAuth."
    enabled:Boolean!

    "The Access-Control-Expose-Headers response header values as described by MDN Access-Control-Expose-Headers."
    exposedHeaders: [String!]

    "The Access-Control-Max-Age response header values as described by MDN Access-Control-Max-Age."
    preflightMaxAgeInSecond: Int
}

type UiConfiguration {
    "A hexadecimal color to override the default menu color in the user interface."
    headerColor: String!

    "A URL of a logo to override the default FusionAuth logo in the user interface."
    logoURL: String!

    "A hexadecimal color to override the default menu font color in the user interface."
    menuFontColor: String!
}

type SystemConfiguration {
    auditLogConfiguration : ConfigurationDeletable!
    
    "The Base64 encoded initialization vector used to encrypt saved request cookies for FusionAuth. This value has been auto-generated and may not be modified."
    cookieEncryptionIV: String!

    "The Base64 encoded encryption key used to encrypt saved request cookies for FusionAuth. This value has been auto-generated and may not be modified."
    cookieEncryptionKey: String!
    corsConfiguration: CorsConfiguration!

    "An object that can hold any information about the System that should be persisted."
    data: JSON!

    loginRecordConfiguration: ConfigurationDeletable!

    "The time zone used to adjust the stored UTC time when generating reports. Since reports are usually rolled up hourly, this timezone will be used for demarcating the hours."
    reportTimezones: String!

    uiConfiguration: UiConfiguration
}




extend type Query {
    "The JSON response from the Status API is complex and subject to change. The specific contents of the JSON body are not documented here. If you choose to use this API for monitoring purposes you should primarily use the response code to indicate server health. If you receive a 200 you may consider FusionAuth in a healthy state. The response body is intended for use by FusionAuth support."
    status: JSON
    "Retrieve the System Configuration"
    systemConfiguration: SystemConfiguration
}


input ConfigurationDeleteInput {
    "Whether or not FusionAuth should delete the Audit Log based upon this configuration. When true the auditLogConfiguration.delete.numberOfDaysToRetain will be used to identify audit logs that are eligible for deletion. When this value is set to false audit logs will be preserved forever."
    enabled: Boolean!
    "The number of days to retain the Audit Log."
    numberOfDaysToRetain: Int!
}

input ConfigurationDeletableInput {delete : ConfigurationDeleteInput!}

input CorsConfigurationInput {
    "The Access-Control-Allow-Credentials response header values as described by MDN Access-Control-Allow-Credentials."
    allowCredentials: Boolean

    "The Access-Control-Allow-Headers response header values as described by MDN Access-Control-Allow-Headers."
    allowedHeaders: [String!]

    "The Access-Control-Allow-Methods response header values as described by MDN Access-Control-Allow-Methods."
    allowedMethods: [HttpMethod!]

    "The Access-Control-Allow-Origin response header values as described by MDN Access-Control-Allow-Origin. If the wildcard * is specified, no additional domains may be specified."
    allowedOrigins: [String!]

    "Whether the FusionAuth CORS filter will process requests made to FusionAuth."
    enabled:Boolean

    "The Access-Control-Expose-Headers response header values as described by MDN Access-Control-Expose-Headers."
    exposedHeaders: [String!]

    "The Access-Control-Max-Age response header values as described by MDN Access-Control-Max-Age."
    preflightMaxAgeInSecond: Int
}

input UiConfigurationInput {
    "A hexadecimal color to override the default menu color in the user interface."
    headerColor: String

    "A URL of a logo to override the default FusionAuth logo in the user interface."
    logoURL: String

    "A hexadecimal color to override the default menu font color in the user interface."
    menuFontColor: String
}

input SystemConfigurationInput {
    auditLogConfiguration : ConfigurationDeletableInput

    corsConfiguration: CorsConfigurationInput

    "An object that can hold any information about the System that should be persisted."
    data: JSON

    loginRecordConfiguration: ConfigurationDeletableInput

    "The time zone used to adjust the stored UTC time when generating reports. Since reports are usually rolled up hourly, this timezone will be used for demarcating the hours."
    reportTimezones: String!

    uiConfiguration: UiConfigurationInput
}

extend type Mutation {
    "Update the System Configuration"
    updateSystemConfiguration(systemConfiguration: SystemConfigurationInput) : SystemConfiguration
}


enum EmailSecurity {
    "no security will be used. All communications will be sent plaintext."
    NONE
    "SSL will be used to connect to the SMTP server. This protocol is not recommended unless it is the only one your SMTP server supports."
    SSL
    "TLS will be used to connect to the SMTP server. This is the preferred protocol for all SMTP servers."
    TLS
}

type RememberPreviousPasswords {

    "The number of previous passwords that should be remembered so they are not re-used by the User."
    count: Int!

    "Indicates that the remember previous password validation is enabled and being enforced."
    enabled: Boolean!
}

type PasswordValidationRules {
    "The maximum number of characters that are allowed for user passwords."
    maxLength: Int!

    "The minimum number of characters that are required for user passwords."
    minLength: Int!

    rememberPreviousPasswords: RememberPreviousPasswords!

    "Indicates that passwords require an uppercase and lowercase character to be valid."
    requireMixedCase: Boolean!

    "Indicates that passwords require a non-alphanumeric character to be valid."
    requireNonAlpha: Boolean!

    "Indicates that passwords require at least one number to be valid."
    requireNumber: Boolean!
}

input EmailConfigurationInput {

    "Defaults to no-reply@fusionauth.io The default email address that emails will be sent from when a from address is not provided on an individual email template. This is the address part email address (i.e. Jared Dunn <jared@piedpiper.com>)."
    defaultFromEmail: String
    "The default From Name used in sending emails when a from name is not provided on an individual email template. This is the display name part of the email address ( i.e. Jared Dunn <jared@piedpiper.com>)."
    defaultFromName: String
    "The Id of the Email Template that is used when a user is sent a forgot password email."
    forgotPasswordEmailTemplateId: UUID
    "The host name of the SMTP server that FusionAuth will use."
    host: String
    "An optional password FusionAuth will use to authenticate with the SMTP server."
    password: String
    "The Id of the Passwordless Email Template."
    passwordlessEmailTemplateId: UUID
    "The port of the SMTP server that FusionAuth will use."
    port: Int
    "Additional Email Configuration in a properties file formatted String."
    properties: String

    """Defaults to NONE. 
    The type of security protocol FusionAuth will use when connecting to the SMTP server. The possible values are:
    
    NONE - no security will be used. All communications will be sent plaintext.
    SSL - SSL will be used to connect to the SMTP server. This protocol is not recommended unless it is the only one your SMTP server supports.
    TLS - TLS will be used to connect to the SMTP server. This is the preferred protocol for all SMTP servers."""
    security: EmailSecurity

    "The Id of the Email Template that is used when a user had their account created for them and they must set their password manually and they are sent an email to set their password."
    setPasswordEmailTemplateId: UUID
    "An optional username FusionAuth will to authenticate with the SMTP server."
    username: String
    "The If of the Email Template that is used to send the verification emails to users. These emails are used to verify that a user’s email address is valid. If either the verifyEmail or verifyEmailWhenChanged fields are true this field is required."
    verificationEmailTemplateId: UUID
    "Defaults to false. Whether the user’s email addresses are verified when the registers with your application."
    verifyEmail: Boolean
    "Defaults to false. Whether the user’s email addresses are verified when the user changes them."
    verifyEmailWhenChanged: Boolean
}


enum EventTransactionType {
    "No Webhooks are required to succeed for the FusionAuth transaction to be committed."
    NONE
    "Only a single Webhook is required to succeed for the FusionAuth transaction to be committed."
    ANY
    "A simple majority (50% or more) of Webhooks are required to succeed for the FusionAuth transaction to be committed."
    SIMPLE_MAJORITY
    "A super majority (2/3 or more) of Webhooks are required to succeed for the FusionAuth transaction to be committed."
    SUPER_MAJORITY
    "Every Webhook must succeed for the FusionAuth transaction to be committed."
    ABSOLUTE_MAJORITY
}

input EventMapEntryInput {
    eventType : String!
    "Defaults to false. Whether or not FusionAuth should send these types of events to any configured Webhooks."
    enabled: Boolean

    "The transaction type that FusionAuth uses when sending these types of events to any configured Webhooks"
    transactionType: EventTransactionType
}


input EventConfigurationInput {
"""
        A mapping of the configuration for each event type that FusionAuth sends. The event types that are the keys into this Object are:

      *user.action - When a user action is triggered
      *user.bulk.create - When multiple users are created in bulk (i.e. during an import)
      *user.create - When a user is created
      *user.email.verified - When a user verifies their email address
      *user.update - When a user is updated
      *user.deactivate - When a user is deactivated
      *user.reactivate - When a user is reactivateduser.login.success - When a user completes a login request
      *user.login.failed - When a user fails a login request
      *user.password.breach - When Reactor detects a user is using a potentially breached password (requires an activated license)
      *user.registration.create - When a user registration is created
      *user.registration.update - When a user registration is updated
      *user.registration.delete - When a user registration is deleted
      *user.registration.verified - When a user completes registration verification
      *user.delete - When a user is deleted
      *jwt.public-key.update - When a JWT RSA Public / Private keypair may have been changed
      *jwt.refresh - When an access token is refreshed using a refresh token
      *jwt.refresh-token.revoke - When a JWT Refresh Token is revoked"""

    events: [EventMapEntryInput!]
}

input ChangeGeneratorInput {
    """The length of the secure generator used for generating the change password Id.

    If the changePasswordIdGenerator.type == randomAlpha then the length must be >= 4 and ⇐ 12. If the changePasswordIdGenerator.type == randomAlphaNumeric then the length must be >= 4 and ⇐ 12. If the changePasswordIdGenerator.type == randomBytes then the length must be >= 16 and ⇐ 128. If the changePasswordIdGenerator.type == randomDigits then the length must be >= 4 and ⇐ 12.
    """
    length: Int

    "The type of the secure generator used for generating the change password Id."
    type: DeviceUserCodeIdGeneratorType
}

input ExternalIdentifierConfigurationInput
{
    """The time in seconds until a OAuth authorization code in no longer valid to be exchanged for an access token. This is essentially the time allowed between the start of an Authorization request during the Authorization code grant and when you request an access token using this authorization code on the Token endpoint.

Value must be greater than 0 and less than or equal to 600."""
    authorizationGrantIdTimeToLiveInSeconds: Int!

    changePasswordIdGenerator: ChangeGeneratorInput!
    "The time in seconds until a change password Id is no longer valid and cannot be used by the Change Password API. Value must be greater than 0."
    changePasswordIdTimeToLiveInSeconds: Int!
    "The time in seconds until a device code Id is no longer valid and cannot be used by the Token API. Value must be greater than 0."
    deviceCodeTimeToLiveInSeconds: Int!
    "The length of the secure generator used for generating the device code Id."

    deviceUserCodeIdGenerator: ChangeGeneratorInput!
    emailVerificationIdGenerator: ChangeGeneratorInput!
    "The time in seconds until an external authentication Id is no longer valid and cannot be used by the Token API. Value must be greater than 0."
    externalAuthenticationIdTimeToLiveInSeconds: Int!

    "The time in seconds until a One Time Password is no longer valid and cannot be used by the Login API. Value must be greater than 0."
    oneTimePasswordTimeToLiveInSeconds: Int!
    passwordlessLoginGenerator: ChangeGeneratorInput!

    registrationVerificationIdGenerator: ChangeGeneratorInput!

    "The time in seconds until a registration verification Id is no longer valid and cannot be used by the Verify Registration API. Value must be greater than 0."
    registrationVerificationIdTimeToLiveInSeconds: Int!

    setupPasswordIdGenerator: ChangeGeneratorInput!

    "The time in seconds until a setup password Id is no longer valid and cannot be used by the Change Password API. Value must be greater than 0."
    setupPasswordIdTimeToLiveInSeconds: Int!

    "The time in seconds until a two factor Id is no longer valid and cannot be used by the Two Factor Login API. Value must be greater than 0."
    twoFactorIdTimeToLiveInSeconds: Int!

    "The time in seconds until an issued Two Factor trust Id is no longer valid and the User will be required to complete Two Factor authentication during the next authentication attempt. Value must be greater than 0."
    twoFactorTrustIdTimeToLiveInSeconds: Int!
}


input FailedAuthenticationConfigurationInput {
    "Defaults to 3. The duration of the User Action. This value along with the actionDurationUnit will be used to set the duration of the User Action. Value must be greater than 0."
    actionDuration: Int!

    "The unit of time associated with a duration. Defaults to MINUTES"
    actionDurationUnit: DurationUnit!

    """Defaults to 60

    The length of time in seconds before the failed authentication count will be reset. Value must be greater than 0.

    For example, if tooManyAttempts is set to 5 and you fail to authenticate 4 times in a row, waiting for the duration specified here will cause your fifth attempt to start back at 1.
    """
    resetCountInSeconds: Int!

    "Defaults to 5. The number of failed attempts considered to be too many. Once this threshold is reached the specified User Action will be applied to the user for the duration specified. Value must be greater than 0."
    tooManyAttempts: Int!

    "The Id of the User Action that is applied when the threshold is reached for too many failed authentication attempts."
    userActionId: UUID

}

input FamilyConfigurationInput {
    "Defaults to true. Whether to allow child registrations."
    allowChildRegistrations: Boolean
    "The unique Id of the email template to use when confirming a child."
    confirmChildEmailTemplateId: UUID
    "Defaults to false. Indicates that child users without parental verification will be permanently deleted after tenant.familyConfiguration.deleteOrphanedAccountsDays days."
    deleteOrphanedAccounts: Boolean
    " Defaults to 30. The number of days from creation child users will be retained before being deleted for not completing parental verification. Value must be greater than 0."
    deleteOrphanedAccountsDays: Int
    "Whenher family configuration is enabled."
    enabled: Boolean
    "Defaults to false. The unique Id of the email template to use when a family request is made."
    familyRequestEmailTemplateId: UUID
    " Defaults to 12. The maximum age of a child. Value must be greater than 0."
    maximumChildAge: Int
    "The minimum age to be an owner. Value must be greater than 0."
    minimumOwnerAge: Int
    " Defaults to false. Whether a parent email is required."
    parentEmailRequired: Boolean
    "The unique Id of the email template to use for parent registration."
    parentRegistrationEmailTemplateId: UUID
}

input PasswordEncryptionConfigurationInput {

    "Defaults to \"salted-pbkdf2-hmac-sha256\".The default method for encrypting the User’s password."
    encryptionScheme: EncryptionScheme

    "Defaults to 24000. The factor used by the password encryption scheme. If not provided, the PasswordEncryptor provides a default value. Generally this will be used as an iteration count to generate the hash. The actual use of this value is up to the PasswordEncryptor implementation."
    encryptionSchemeFactor: Int

    "Defaults to false. When enabled a user’s hash configuration will be modified to match these configured settings. This can be useful to increase a password hash strength over time or upgrade imported users to a more secure encryption scheme after an initial import."
    modifyEncryptionSchemeOnLogin: Boolean

}

input BreachDetectionInput
{
    "Defaults to false. Whether to enable Reactor breach detection. Requires an activated license."
    enabled: Boolean

    "The level of severity where Reactor will consider a breach."
    matchMode: BreachDetectionMode

    "The Id of the email template to use when notifying user of breached password. Required if onLogin is set to NotifyUser."
    notifyUserEmailTemplateId: UUID

    "The behavior when detecting breaches at time of user login."
    onLogin: BreachDetectionBehavior

}


input RememberPreviousPasswordsInput
{
    "The number of previous passwords that should be remembered so they are not re-used by the User."
    count: Int

    "Indicates that the remember previous password validation is enabled and being enforced."
    enabled: Boolean
}

input PasswordValidationRulesInput
{
    breachDetection: BreachDetectionInput

    "Defaults to 256. The maximum length of a password when a new user is created or a user requests a password change."
    maxLength: Int
    "Defaults to 8. The minimum length of a password when a new user is created or a user requests a password change."
    minLength: Int

    rememberPreviousPasswords: RememberPreviousPasswordsInput

    "Defaults to false. Whether to force the user to use at least one uppercase and one lowercase character."
    requiredMixedCase: Boolean

    "Defaults to false. Whether to force the user to use at least one non-alphanumeric character."
    requireNonAlpha: Boolean

    "Defaults to false. Whether to force the user to use at least one number."
    requireNumber: Boolean

    "Defaults to false. When enabled the user’s password will be validated during login. If the password does not meet the currently configured validation rules the user will be required to change their password."
    validateOnLogin: Boolean
}

input TenantInput {
    "An object that can hold any information about the Tenant that should be persisted."
    data: JSON
    emailConfiguration: EmailConfigurationInput
    eventConfiguration: EventConfigurationInput
    externalIdentifierConfiguration: ExternalIdentifierConfigurationInput
    failedAuthenticationConfiguration: FailedAuthenticationConfigurationInput
    familyConfigurationInput: FamilyConfigurationInput

    "Default is 3600. Time in seconds until an inactive session will be invalidated. Used when creating a new session in the FusionAuth OAuth frontend."
    httpSessionMaxInactiveInterval: Int

    "The named issuer used to sign tokens, this is generally your public fully qualified domain."
    issuer: String!

    jwtConfiguration: JwtConfigurationInput

    "The logout redirect URL when sending the user’s browser to the /oauth2/logout URI of the FusionAuth Front End. This value is only used when a logout URL is not defined in your Application."
    logoutURL: String

    "The password maximum age in days. The number of days after which FusionAuth will require a user to change their password. To disable pass null."
    maximumPasswordAgeInDays: Int

    "The password minimum age in seconds. When enabled FusionAuth will not allow a password to be changed until it reaches this minimum age. "
    minimumPasswordAge: Int

    "The unique name of the Tenant."
    name: String

    passwordEncryptionConfiguration: PasswordEncryptionConfigurationInput

    passwordValidationRules: PasswordValidationRulesInput

    "The unique Id of the theme to be used to style the login page and other end user templates."
    themeId: UUID!
    userDeletePolicy: RegistrationDeletePolicyUnverifiedInput
}


type EmailConfiguration {

    "Defaults to no-reply@fusionauth.io The default email address that emails will be sent from when a from address is not provided on an individual email template. This is the address part email address (i.e. Jared Dunn <jared@piedpiper.com>)."
    defaultFromEmail: String!
    "The default From Name used in sending emails when a from name is not provided on an individual email template. This is the display name part of the email address ( i.e. Jared Dunn <jared@piedpiper.com>)."
    defaultFromName: String!
    "The Id of the Email Template that is used when a user is sent a forgot password email."
    forgotPasswordEmailTemplateId: UUID!
    forgotPasswordEmailTemplate: EmailTemplate

    "The host name of the SMTP server that FusionAuth will use."
    host: String!
    "An optional password FusionAuth will use to authenticate with the SMTP server."
    password: String!
    "The Id of the Passwordless Email Template."
    passwordlessEmailTemplateId: UUID
    passwordlessEmailTemplate: EmailTemplate
    !
    "The port of the SMTP server that FusionAuth will use."
    port: Int!
    "Additional Email Configuration in a properties file formatted String."
    properties: String!

    """Defaults to NONE.
    The type of security protocol FusionAuth will use when connecting to the SMTP server. The possible values are:

    NONE - no security will be used. All communications will be sent plaintext.
    SSL - SSL will be used to connect to the SMTP server. This protocol is not recommended unless it is the only one your SMTP server supports.
    TLS - TLS will be used to connect to the SMTP server. This is the preferred protocol for all SMTP servers."""
    security: EmailSecurity!

    "The Id of the Email Template that is used when a user had their account created for them and they must set their password manually and they are sent an email to set their password."
    setPasswordEmailTemplateId: UUID!
    setPasswordEmailTemplate: EmailTemplate

    "An optional username FusionAuth will to authenticate with the SMTP server."
    username: String!
    "The If of the Email Template that is used to send the verification emails to users. These emails are used to verify that a user’s email address is valid. If either the verifyEmail or verifyEmailWhenChanged fields are true this field is required."
    verificationEmailTemplateId: UUID!
    verificationEmailTemplate: EmailTemplate

    "Defaults to false. Whether the user’s email addresses are verified when the registers with your application."
    verifyEmail: Boolean!
    "Defaults to false. Whether the user’s email addresses are verified when the user changes them."
    verifyEmailWhenChanged: Boolean!
}

type EventMapEntry {
    eventType: String!
    
    "Defaults to false. Whether or not FusionAuth should send these types of events to any configured Webhooks."
    enabled: Boolean

    "The transaction type that FusionAuth uses when sending these types of events to any configured Webhooks"
    transactionType: EventTransactionType
}


type EventConfiguration {
    """
    A mapping of the configuration for each event type that FusionAuth sends. The event types that are the keys into this Object are:

    *user.action - When a user action is triggered
    *user.bulk.create - When multiple users are created in bulk (i.e. during an import)
    *user.create - When a user is created
    *user.email.verified - When a user verifies their email address
    *user.update - When a user is updated
    *user.deactivate - When a user is deactivated
    *user.reactivate - When a user is reactivateduser.login.success - When a user completes a login request
    *user.login.failed - When a user fails a login request
    *user.password.breach - When Reactor detects a user is using a potentially breached password (requires an activated license)
    *user.registration.create - When a user registration is created
    *user.registration.update - When a user registration is updated
    *user.registration.delete - When a user registration is deleted
    *user.registration.verified - When a user completes registration verification
    *user.delete - When a user is deleted
    *jwt.public-key.update - When a JWT RSA Public / Private keypair may have been changed
    *jwt.refresh - When an access token is refreshed using a refresh token
    *jwt.refresh-token.revoke - When a JWT Refresh Token is revoked"""

    events: [EventMapEntry!]
}

enum DeviceUserCodeIdGeneratorType {
    RANDOM_ALPHA
    RANDOM_ALPHANUMERIC
    RANDOM_BYTES
    RANDOM_DIGITS
}

type ChangeGenerator {
    """The length of the secure generator used for generating the change password Id.

    If the changePasswordIdGenerator.type == randomAlpha then the length must be >= 4 and ⇐ 12. If the changePasswordIdGenerator.type == randomAlphaNumeric then the length must be >= 4 and ⇐ 12. If the changePasswordIdGenerator.type == randomBytes then the length must be >= 16 and ⇐ 128. If the changePasswordIdGenerator.type == randomDigits then the length must be >= 4 and ⇐ 12.
    """
    length: Int

    "The type of the secure generator used for generating the change password Id."
    type: DeviceUserCodeIdGeneratorType
}

type ExternalIdentifierConfiguration
{
    """The time in seconds until a OAuth authorization code in no longer valid to be exchanged for an access token. This is essentially the time allowed between the start of an Authorization request during the Authorization code grant and when you request an access token using this authorization code on the Token endpoint.

    Value must be greater than 0 and less than or equal to 600."""
    authorizationGrantIdTimeToLiveInSeconds: Int!

    changePasswordIdGenerator: ChangeGenerator!
    "The time in seconds until a change password Id is no longer valid and cannot be used by the Change Password API. Value must be greater than 0."
    changePasswordIdTimeToLiveInSeconds: Int!
    "The time in seconds until a device code Id is no longer valid and cannot be used by the Token API. Value must be greater than 0."
    deviceCodeTimeToLiveInSeconds: Int!
    "The length of the secure generator used for generating the device code Id."

    deviceUserCodeIdGenerator: ChangeGenerator!
    emailVerificationIdGenerator: ChangeGenerator!
    "The time in seconds until an external authentication Id is no longer valid and cannot be used by the Token API. Value must be greater than 0."
    externalAuthenticationIdTimeToLiveInSeconds: Int!

    "The time in seconds until a One Time Password is no longer valid and cannot be used by the Login API. Value must be greater than 0."
    oneTimePasswordTimeToLiveInSeconds: Int!
    passwordlessLoginGenerator: ChangeGenerator!

    registrationVerificationIdGenerator: ChangeGenerator!

    "The time in seconds until a registration verification Id is no longer valid and cannot be used by the Verify Registration API. Value must be greater than 0."
    registrationVerificationIdTimeToLiveInSeconds: Int!

    setupPasswordIdGenerator: ChangeGenerator!

    "The time in seconds until a setup password Id is no longer valid and cannot be used by the Change Password API. Value must be greater than 0."
    setupPasswordIdTimeToLiveInSeconds: Int!

    "The time in seconds until a two factor Id is no longer valid and cannot be used by the Two Factor Login API. Value must be greater than 0."
    twoFactorIdTimeToLiveInSeconds: Int!

    "The time in seconds until an issued Two Factor trust Id is no longer valid and the User will be required to complete Two Factor authentication during the next authentication attempt. Value must be greater than 0."
    twoFactorTrustIdTimeToLiveInSeconds: Int!
}

enum DurationUnit {
    MINUTES
    HOURS
    DAYS
    WEEKS
    MONTHS
    YEARS
}

type FailedAuthenticationConfiguration {
    "Defaults to 3. The duration of the User Action. This value along with the actionDurationUnit will be used to set the duration of the User Action. Value must be greater than 0."
    actionDuration: Int!

    "The unit of time associated with a duration. Defaults to MINUTES"
    actionDurationUnit: DurationUnit!

    """Defaults to 60

    The length of time in seconds before the failed authentication count will be reset. Value must be greater than 0.

    For example, if tooManyAttempts is set to 5 and you fail to authenticate 4 times in a row, waiting for the duration specified here will cause your fifth attempt to start back at 1.
    """
    resetCountInSeconds: Int!

    "Defaults to 5. The number of failed attempts considered to be too many. Once this threshold is reached the specified User Action will be applied to the user for the duration specified. Value must be greater than 0."
    tooManyAttempts: Int!

    "The Id of the User Action that is applied when the threshold is reached for too many failed authentication attempts."
    userActionId: UUID
    userAction: UserAction
}

type FamilyConfiguration {
    "Defaults to true. Whether to allow child registrations."
    allowChildRegistrations: Boolean
    "The unique Id of the email template to use when confirming a child."
    confirmChildEmailTemplateId: UUID
    confirmChildEmailTemplate: EmailTemplate

    "Defaults to false. Indicates that child users without parental verification will be permanently deleted after tenant.familyConfiguration.deleteOrphanedAccountsDays days."
    deleteOrphanedAccounts: Boolean
    " Defaults to 30. The number of days from creation child users will be retained before being deleted for not completing parental verification. Value must be greater than 0."
    deleteOrphanedAccountsDays: Int
    "Whenher family configuration is enabled."
    enabled: Boolean
    "Defaults to false. The unique Id of the email template to use when a family request is made."
    familyRequestEmailTemplateId: UUID
    familyRequestEmailTemplate: EmailTemplate
    " Defaults to 12. The maximum age of a child. Value must be greater than 0."
    maximumChildAge: Int
    "The minimum age to be an owner. Value must be greater than 0."
    minimumOwnerAge: Int
    " Defaults to false. Whether a parent email is required."
    parentEmailRequired: Boolean
    "The unique Id of the email template to use for parent registration."
    parentRegistrationEmailTemplateId: UUID
    parentRegistrationEmailTemplate: EmailTemplate
}

type PasswordEncryptionConfiguration {

    "Defaults to \"salted-pbkdf2-hmac-sha256\".The default method for encrypting the User’s password."
    encryptionScheme: EncryptionScheme

    "Defaults to 24000. The factor used by the password encryption scheme. If not provided, the PasswordEncryptor provides a default value. Generally this will be used as an iteration count to generate the hash. The actual use of this value is up to the PasswordEncryptor implementation."
    encryptionSchemeFactor: Int

    "Defaults to false. When enabled a user’s hash configuration will be modified to match these configured settings. This can be useful to increase a password hash strength over time or upgrade imported users to a more secure encryption scheme after an initial import."
    modifyEncryptionSchemeOnLogin: Boolean

}

enum BreachDetectionMode
{
    "Only requires a password match, this is the most secure and is recommended" HIGH
    "Exact match on username, email address or email sub-address" MEDIUM
    "Exact match on an email or username, or the password is a common breached value" LOW
}

enum BreachDetectionBehavior
{
    "Do not perform breach detection at login" OFF
    "Only record the result, take no action"   RECORD_ONLY
    "Notify the end user via email"            NOTIFY_USER
    "Require immediate password change"        REQUIRE_CHANGE
}

type BreachDetection
{
    "Defaults to false. Whether to enable Reactor breach detection. Requires an activated license."
    enabled: Boolean

    "The level of severity where Reactor will consider a breach."
    matchMode: BreachDetectionMode

    "The Id of the email template to use when notifying user of breached password. Required if onLogin is set to NotifyUser."
    notifyUserEmailTemplateId: UUID
    notifyUserEmailTemplate: EmailTemplate

    "The behavior when detecting breaches at time of user login."
    onLogin: BreachDetectionBehavior

}


type Tenant {
    "An object that can hold any information about the Tenant that should be persisted."
    data: JSON

    eventConfiguration: EventConfiguration
    externalIdentifierConfiguration: ExternalIdentifierConfiguration
    failedAuthenticationConfiguration: FailedAuthenticationConfiguration
    familyConfigurationInput: FamilyConfiguration

    "Default is 3600. Time in seconds until an inactive session will be invalidated. Used when creating a new session in the FusionAuth OAuth frontend."
    httpSessionMaxInactiveInterval: Int

    "The named issuer used to sign tokens, this is generally your public fully qualified domain."
    issuer: String!

    "The unique identifier for this Tenant."
    id : UUID!

    jwtConfiguration: JwtConfiguration!

    "The logout redirect URL when sending the user’s browser to the /oauth2/logout URI of the FusionAuth Front End. This value is only used when a logout URL is not defined in your Application."
    logoutURL: String!

    "The password maximum age in days. The number of days after which FusionAuth will require a user to change their password. To disable pass null."
    maximumPasswordAgeInDays: Int

    "The password minimum age in seconds. When enabled FusionAuth will not allow a password to be changed until it reaches this minimum age. "
    minimumPasswordAge: Int

    "The unique name of the Tenant."
    name: String

    passwordEncryptionConfiguration: PasswordEncryptionConfiguration

    passwordValidationRules: PasswordValidationRules

    "The unique Id of the theme to be used to style the login page and other end user templates."
    themeId: UUID!
    theme: Theme
    userDeletePolicy: RegistrationDeletePolicyUnverified
}


extend type Mutation {
    createTenant(
        "The optional Id of an existing Tenant to make a copy of. If present, the tenant.id and tenant.name values of the request body will be applied to the new Tenant, all other values will be copied from the source Tenant to the new Tenant."
        sourceTenantId: UUID,
        tenant: TenantInput!
    ) : Tenant

    updateTenant(
        "The Id of the Tenant to update."
        tenantId: UUID!,
        tenant: TenantInput!
    ) : Tenant

    deleteTenant(tenantId: UUID!): Boolean
}

"A `Tenant` edge in the connection."
type TenantsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Tenant` at the end of the edge."
    node: Tenant
}

"A connection to a list of `Tenant` values."
type TenantsConnection {
    "A list of edges which contains the `Tenant` and cursor to aid in pagination."
    edges: [TenantsEdge!]!
    "A list of `Tenant` objects."
    nodes: [Tenant]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Tenant` you could get from the connection."
    totalCount: Int!
}


extend type Query {
    tenant(tenantId: UUID!) : Tenant
    "Reads and enables pagination through a set of `Theme`."
    tenants(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int
    ): TenantsConnection!

    tenantPasswordValidationRules(tenantId: UUID!): PasswordValidationRules
}


input TemplatesInput {
    "A FreeMarker template that is rendered when the user requests the /email/complete page. This page is used after a user has verified their email address by clicking the URL in the email. After FusionAuth has updated their user object to indicate that their email was verified, the browser is redirected to this page."
    emailComplete: String
    "A FreeMarker template that is rendered when the user requests the /email/send page. This page is used after a user has asked for the verification email to be resent. This can happen if the URL in the email expired and the user clicked it. In this case, the user can provide their email address again and FusionAuth will resend the email. After the user submits their email and FusionAuth re-sends a verification email to them, the browser is redirected to this page."
    emailSend: String
    "A FreeMarker template that is rendered when the user requests the /email/verify page by clicking the URL from the verification email and the verificationId has expired. FusionAuth expires verificationId after a period of time (which is configurable). If the user has a URL from the verification email that has expired, this page will be rendered and the error will be displayed to the user."
    emailVerify: String
    "A FreeMarker template that contains all of the macros and templates used by the rest of the loginTheme FreeMarker templates (i.e. oauth2Authorize). This allows you to configure the general layout of your UI configuration and login theme without having to copy and paste HTML into each of the templates."
    helpers: String
    "A FreeMarker template that is rendered when the user requests the /oauth2/authorize page. This is the main login page for FusionAuth and is used for all interactive OAuth and OpenId Connect workflows."
    oauth2Authorize: String
    "A FreeMarker template that is rendered when the user requests the /oauth2/child-registration-not-allowed page. This is where the child must provide their parent’s email address to ask their parent to create an account for them."
    oauth2ChildRegistrationNotAllowed: String
    "A FreeMarker template that is rendered when the user requests the /oauth2/child-registration-not-allowed-complete page. This is where the browser is taken after the child provides their parent’s email address."
    oauth2ChildRegistrationNotAllowedComplete: String
    "A FreeMarker template that is rendered when the user requests the /oauth2/complete-registration page. This page is used for users that have accounts but might be missing required fields."
    oauth2CompleteRegistration: String
    "A FreeMarker template that is rendered when the user requests the /oauth2/error page. This page is used if the user starts or is in the middle of the OAuth workflow and any type of error occurs. This could be caused by the user messing with the URL or internally some type of information wasn’t passed between the OAuth endpoints correctly. For example, if you are federating login to an external IdP and that IdP does not properly echo the state parameter, FusionAuth’s OAuth workflow will break and this page will be displayed."
    oauth2Error: String
    "A FreeMarker template that is rendered when the user requests the /oauth2/logout page. This page is used if the user initiates a logout. This page causes the user to be logged out of all associated applications via a front-channel mechanism before being redirected."
    oauth2Logout: String
    "A FreeMarker template that is rendered when the user requests the /oauth2/register page. This page is used for users that need to register (sign-up)"
    oauth2Register: String
    "A FreeMarker template that is rendered when the user requests the /oauth2/two-factor page. This page is used if the user has two-factor authentication enabled and they need to type in their code again. FusionAuth will properly handle the SMS or authenticator app processing on the back end. This page contains the form that the user will put their code into."
    oauth2TwoFactor: String
    "A FreeMarker template that is rendered when the user requests the /password/change page. This page is used if the user is required to change their password or if they have requested a password reset. This page contains the form that allows the user to provide a new password."
    passwordChange: String
    "A FreeMarker template that is rendered when the user requests the /password/complete page. This page is used after the user has successfully updated their password (or reset it). This page should instruct the user that their password was updated and that they need to login again."
    passwordComplete: String
    "A FreeMarker template that is rendered when the user requests the /password/forgot page. This page is used when a user starts the forgot password workflow. This page renders the form where the user types in their email address."
    passwordForgot: String
    "A FreeMarker template that is rendered when the user requests the /password/sent page. This page is used when a user has submitted the forgot password form with their email. FusionAuth does not indicate back to the user if their email address was valid in order to prevent malicious activity that could reveal valid email addresses. Therefore, this page should indicate to the user that if their email was valid, they will receive an email shortly with a link to reset their password."
    passwordSent: String
    "A FreeMarker template that is rendered when the user requests the /registration/complete page. This page is used after a user has verified their email address for a specific application (i.e. a user registration) by clicking the URL in the email. After FusionAuth has updated their registration object to indicate that their email was verified, the browser is redirected to this page."
    registrationComplete: String
    "A FreeMarker template that is rendered when the user requests the /registration/send page. This page is used after a user has asked for the application specific verification email to be resent. This can happen if the URL in the email expired and the user clicked it. In this case, the user can provide their email address again and FusionAuth will resend the email. After the user submits their email and FusionAuth re-sends a verification email to them, the browser is redirected to this page."
    registrationSend: String
    "A FreeMarker template that is rendered when the user requests the /registration/verify page by clicking the URL from the application specific verification email and the verificationId has expired. FusionAuth expires verificationId after a period of time (which is configurable). If the user has a URL from the verification email that has expired, this page will be rendered and the error will be displayed to the user."
    registrationVerify: String
}


input ThemeInput {
    "A properties file formatted String containing at least all of the message keys defined in the FusionAuth shipped messages file. Required if not copying an existing Theme."
    defaultMessages: String!

    "A Map of localized versions of the messages. The key is the Locale and the value is a properties file formatted String."
    localizedMessages: [LocalizedStringInput!]

    "A unique name for the Theme."
    name: String

    "A CSS stylesheet used to style the templates."
    stylesheet: String

    templates: TemplatesInput
}



type Templates {
    "A FreeMarker template that is rendered when the user requests the /email/complete page. This page is used after a user has verified their email address by clicking the URL in the email. After FusionAuth has updated their user object to indicate that their email was verified, the browser is redirected to this page."
    emailComplete: String
    "A FreeMarker template that is rendered when the user requests the /email/send page. This page is used after a user has asked for the verification email to be resent. This can happen if the URL in the email expired and the user clicked it. In this case, the user can provide their email address again and FusionAuth will resend the email. After the user submits their email and FusionAuth re-sends a verification email to them, the browser is redirected to this page."
    emailSend: String
    "A FreeMarker template that is rendered when the user requests the /email/verify page by clicking the URL from the verification email and the verificationId has expired. FusionAuth expires verificationId after a period of time (which is configurable). If the user has a URL from the verification email that has expired, this page will be rendered and the error will be displayed to the user."
    emailVerify: String
    "A FreeMarker template that contains all of the macros and templates used by the rest of the loginTheme FreeMarker templates (i.e. oauth2Authorize). This allows you to configure the general layout of your UI configuration and login theme without having to copy and paste HTML into each of the templates."
    helpers: String
    "A FreeMarker template that is rendered when the user requests the /oauth2/authorize page. This is the main login page for FusionAuth and is used for all interactive OAuth and OpenId Connect workflows."
    oauth2Authorize: String
    "A FreeMarker template that is rendered when the user requests the /oauth2/child-registration-not-allowed page. This is where the child must provide their parent’s email address to ask their parent to create an account for them."
    oauth2ChildRegistrationNotAllowed: String
    "A FreeMarker template that is rendered when the user requests the /oauth2/child-registration-not-allowed-complete page. This is where the browser is taken after the child provides their parent’s email address."
    oauth2ChildRegistrationNotAllowedComplete: String
    "A FreeMarker template that is rendered when the user requests the /oauth2/complete-registration page. This page is used for users that have accounts but might be missing required fields."
    oauth2CompleteRegistration: String
    "A FreeMarker template that is rendered when the user requests the /oauth2/error page. This page is used if the user starts or is in the middle of the OAuth workflow and any type of error occurs. This could be caused by the user messing with the URL or internally some type of information wasn’t passed between the OAuth endpoints correctly. For example, if you are federating login to an external IdP and that IdP does not properly echo the state parameter, FusionAuth’s OAuth workflow will break and this page will be displayed."
    oauth2Error: String
    "A FreeMarker template that is rendered when the user requests the /oauth2/logout page. This page is used if the user initiates a logout. This page causes the user to be logged out of all associated applications via a front-channel mechanism before being redirected."
    oauth2Logout: String
    "A FreeMarker template that is rendered when the user requests the /oauth2/register page. This page is used for users that need to register (sign-up)"
    oauth2Register: String
    "A FreeMarker template that is rendered when the user requests the /oauth2/two-factor page. This page is used if the user has two-factor authentication enabled and they need to type in their code again. FusionAuth will properly handle the SMS or authenticator app processing on the back end. This page contains the form that the user will put their code into."
    oauth2TwoFactor: String
    "A FreeMarker template that is rendered when the user requests the /password/change page. This page is used if the user is required to change their password or if they have requested a password reset. This page contains the form that allows the user to provide a new password."
    passwordChange: String
    "A FreeMarker template that is rendered when the user requests the /password/complete page. This page is used after the user has successfully updated their password (or reset it). This page should instruct the user that their password was updated and that they need to login again."
    passwordComplete: String
    "A FreeMarker template that is rendered when the user requests the /password/forgot page. This page is used when a user starts the forgot password workflow. This page renders the form where the user types in their email address."
    passwordForgot: String
    "A FreeMarker template that is rendered when the user requests the /password/sent page. This page is used when a user has submitted the forgot password form with their email. FusionAuth does not indicate back to the user if their email address was valid in order to prevent malicious activity that could reveal valid email addresses. Therefore, this page should indicate to the user that if their email was valid, they will receive an email shortly with a link to reset their password."
    passwordSent: String
    "A FreeMarker template that is rendered when the user requests the /registration/complete page. This page is used after a user has verified their email address for a specific application (i.e. a user registration) by clicking the URL in the email. After FusionAuth has updated their registration object to indicate that their email was verified, the browser is redirected to this page."
    registrationComplete: String
    "A FreeMarker template that is rendered when the user requests the /registration/send page. This page is used after a user has asked for the application specific verification email to be resent. This can happen if the URL in the email expired and the user clicked it. In this case, the user can provide their email address again and FusionAuth will resend the email. After the user submits their email and FusionAuth re-sends a verification email to them, the browser is redirected to this page."
    registrationSend: String
    "A FreeMarker template that is rendered when the user requests the /registration/verify page by clicking the URL from the application specific verification email and the verificationId has expired. FusionAuth expires verificationId after a period of time (which is configurable). If the user has a URL from the verification email that has expired, this page will be rendered and the error will be displayed to the user."
    registrationVerify: String
}


type Theme {
    "A properties file formatted String containing at least all of the message keys defined in the FusionAuth shipped messages file. Required if not copying an existing Theme."
    defaultMessages: String!

    "A Map of localized versions of the messages. The key is the Locale and the value is a properties file formatted String."
    localizedMessages: [LocalizedString!]!

    "The unique Id of the Theme."
    id: UUID!

    "The instant that the theme was added to the FusionAuth database."
    insertInstant: Int

    "The instant that the theme was last updated in the FusionAuth database."
    lastUpdateInstant: Int

    "A unique name for the Theme."
    name: String!

    "A CSS stylesheet used to style the templates."
    stylesheet: String!

    templates: Templates!
}

"A `Theme` edge in the connection."
type ThemesEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Theme` at the end of the edge."
    node: Theme
}

"A connection to a list of `Theme` values."
type ThemesConnection {
    "A list of edges which contains the `Theme` and cursor to aid in pagination."
    edges: [ThemesEdge!]!
    "A list of `Theme` objects."
    nodes: [Theme]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Theme` you could get from the connection."
    totalCount: Int!
}

extend type Query {
    theme(themeId: UUID!): Theme
    "Reads and enables pagination through a set of `Themes`."
    themes(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int
    ): ThemesConnection!
}

extend type Mutation {
    createTheme(
        "The optional Id of an existing Theme to make a copy of. If present, the defaultMessages, localizedMessages, templates, and stylesheet from the source Theme will be copied to the new Theme."
        sourceThemeId: UUID,
        theme: ThemeInput!
    ) : Theme

    updateTheme(
        "The Id of the Theme to update."
        themeId: UUID!,
        theme: ThemeInput!
    ) : Theme

    deleteTheme(themeId: UUID!): Boolean
}

extend type Mutation {
    enableTwoFactor(userId: UUID,
        "A valid Two Factor verification code. This value should be provided by the User to verify they are able to produce codes using an application or receive them using their mobile phone."
        code: String!
        """The User’s preferred delivery for verification codes during a two factor login request.
        When using TextMessage the User will also need a valid mobilePhone. The User’s mobile phone is not validated during this request. Because the code is provided on this request it is assumed the User has been able to receive a code on their mobile phone when setting the delivery to TextMessage."""
        delivery : TwoFactorDelivery!
        """The raw Two Factor secret used to generate the verification code provided on this request. You can technically pass in any value you want here, but in most cases, this is a randomly generate byte array that is Base-64 encoded. If you are bringing over a secret from a third-party system that is Base-32 encoded, you will want to decode that value and Base-64 encode it and pass the Base-64 encoded value in here.

        You may optionally use value provided in the secret field returned by the Two Factor Secret API instead of generating this value yourself. This value is a random byte array that is Base-64 encoded."""
        secret: String!) : Boolean

    disableTwoFactor("The Id of the User to enable Two Factor authentication."
                     userId: UUID,
                     "The time based one time use password, also called a Two Factor verification code."
                     code: String!) : Boolean

    sendTwoFactor(twoFactorId: UUID) : Boolean
    sendTwoFactorToUser(userid: UUID!) : Boolean
    sendTwoFactorToPhone(mobilePhone: String!, secret: String!) : Boolean
    secret : String
}

input UserActionReasonInput {
    "A short code for the User Action Reason."
    code: String!

    "A mapping of localized text for the User Action Reason. The key is the Locale and the value is the localized text."
    localizedTexts: [LocalizedStringInput]

    "The text of the User Action Reason."
    text: String!
}

type UserActionReason {
    "A short code for the User Action Reason."
    code: String!

    "The Id of the User Action Reason."
    id: UUID!

    "A mapping of localized text for the User Action Reason. The key is the Locale and the value is the localized text."
    localizedTexts: [LocalizedString!]

    "The text of the User Action Reason."
    text: String!
}

extend type Mutation {
    createUserActionReason(
        "The Id to use for the new User Action Reason. If not specified a secure random UUID will be generated."
        userActionReasonId: UUID,
        input: UserActionReasonInput!
    ) : UserActionReason

    updateUserActionReason(
        "The Id of the User Action Reason to update."
        userActionReasonId: UUID!,
        input: UserActionReasonInput!
    ) : UserActionReason

    deleteUserActionReason(
        "The Id of the User Action Reason to delete."
        userActionReasonId: UUID!
    ) : UserActionReason
}

"A `UserActionReason` edge in the connection."
type UserActionReasonsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `UserActionReason` at the end of the edge."
    node: UserActionReason
}

"A connection to a list of `UserActionReason` values."
type UserActionReasonsConnection {
    "A list of edges which contains the `UserActionReason` and cursor to aid in pagination."
    edges: [UserActionReasonsEdge!]!
    "A list of `UserActionReason` objects."
    nodes: [UserActionReason]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `UserActionReason` you could get from the connection."
    totalCount: Int!
}

extend type Query {

    userActionReason(userActionReasonId: UUID!) : UserActionReason

    "Reads and enables pagination through a set of `Webhook`."
    userActionReasons(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int
    ): UserActionReasonsConnection!
}

input UserCommentInput {
    "The text of the User Comment."
    userComment : UUID!

    "The Id of the User that wrote the User Comment."
    commenterId : UUID!

    "The Id of the User that the User Comment was written for."
    userId : UUID!
}

type UserComment {
    "The text of the User Comment."
    comment: String!

    "The Id of the User that wrote the User Comment."
    commenterId: UUID!
    commenter: User
    "The instant when the comment was written."
    createInstant: Int!

    "The Id of the User Comment."
    id: UUID!

    "The Id of the User that the User Comment was written for."
    userId: UUID!
    user: User
}

extend type Mutation {
    createUserComment(input: UserCommentInput!) : UserComment
}

"A `UserComment` edge in the connection."
type UserCommentsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `UserComment` at the end of the edge."
    node: UserComment
}

"A connection to a list of `UserComment` values."
type UserCommentsConnection {
    "A list of edges which contains the `UserComment` and cursor to aid in pagination."
    edges: [UserCommentsEdge!]!
    "A list of `UserComment` objects."
    nodes: [UserComment]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `UserComment` you could get from the connection."
    totalCount: Int!
}

extend type Query {
    userComments("The Id of the User to retrieve the User Comments for." userId: UUID!,

        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int) : UserCommentsConnection!
}

extend type User {
    comments(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int) : UserCommentsConnection!
}

input HeaderEntryInput {key: String!, value: String!}

input WebhookInput
{

    "The Ids of the Applications that this Webhook should be associated with. If no Ids are specified and the global field is false, this Webhook will not be used."
    applicationIds: [UUID]

    "The connection timeout in milliseconds used when FusionAuth sends events to the Webhook."
    connectTimeout: Int!

    "A description of the Webhook. This is used for display purposes only."
    description: String

    "A mapping for the events that are enabled for this Webhook. The key of the Object property is the name of the event and the value is a boolean. "
    eventsEnabled: EventConfigurationInput

    "Defaults to false. Whether or not this Webhook is used for all events or just for specific Applications."
    global: Boolean

    "An object that contains headers that are sent as part of the HTTP request for the events."
    headers: [HeaderEntryInput!]

    "The HTTP basic authentication password that is sent as part of the HTTP request for the events."
    httpAuthenticationPassword: String

    "The HTTP basic authentication username that is sent as part of the HTTP request for the events."
    httpAuthenticationUsername: String

    "The read timeout in milliseconds used when FusionAuth sends events to the Webhook."
    readTimeout: Int!

    "An SSL certificate in PEM format that is used to establish the a SSL (TLS specifically) connection to the Webhook."
    sslCertificate: String

    "The fully qualified URL of the Webhook’s endpoint that will accept the event requests from FusionAuth."
    url: String!
}


type HeaderEntry {key: String!, value: String!}

type Webhook
{

    "The Ids of the Applications that this Webhook should be associated with. If no Ids are specified and the global field is false, this Webhook will not be used."
    applicationIds: [UUID]
    applications(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int) : ApplicationsConnection
    "The connection timeout in milliseconds used when FusionAuth sends events to the Webhook."
    connectTimeout: Int!

    "A description of the Webhook. This is used for display purposes only."
    description: String

    "A mapping for the events that are enabled for this Webhook. The key of the Object property is the name of the event and the value is a boolean. "
    eventsEnabled: EventConfiguration

    "Defaults to false. Whether or not this Webhook is used for all events or just for specific Applications."
    global: Boolean

    "An object that contains headers that are sent as part of the HTTP request for the events."
    headers: [HeaderEntry!]

    "The Id of the Webhook."
    id: UUID!

    "The HTTP basic authentication password that is sent as part of the HTTP request for the events."
    httpAuthenticationPassword: String

    "The HTTP basic authentication username that is sent as part of the HTTP request for the events."
    httpAuthenticationUsername: String

    "The read timeout in milliseconds used when FusionAuth sends events to the Webhook."
    readTimeout: Int!

    "An SSL certificate in PEM format that is used to establish the a SSL (TLS specifically) connection to the Webhook."
    sslCertificate: String

    "The fully qualified URL of the Webhook’s endpoint that will accept the event requests from FusionAuth."
    url: String!
}

extend type Mutation {
    createWebhook("The Id to use for the new Webhook. If not specified a secure random UUID will be generated"
                  webhookId: UUID, input: WebhookInput!) : Webhook

    updateWebhook(webhookId: UUID!, input: WebhookInput!) : Webhook
    deleteWebhook(webhookId: UUID!) : Boolean
}

"A `Webhook` edge in the connection."
type WebhooksEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `Webhook` at the end of the edge."
    node: Webhook
}

"A connection to a list of `Webhook` values."
type WebhooksConnection {
    "A list of edges which contains the `Webhook` and cursor to aid in pagination."
    edges: [WebhooksEdge!]!
    "A list of `Webhook` objects."
    nodes: [Webhook]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `Webhook` you could get from the connection."
    totalCount: Int!
}


extend type Query {
    webhook(webhookId: UUID!) : Webhook
    "Reads and enables pagination through a set of `Collaborator`."
    webhooks(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int
    ): WebhooksConnection!
}

input UserActionOptionInput {
    "A mapping of localized names for this User Action Option. The key is the Locale and the value is the name of the User Action Option for that language."
    localizedNames: [LocalizedStringInput!]

    "The name of this User Action Option."
    name: String
}

input UserActionInput {
    "The Id of the Email Template that is used when User Actions are canceled."
    cancelEmailTemplateId : UUID

    "The Id of the Email Template that is used when User Actions expired automatically (end)."
    endEmailTemplateId: UUID

    "The Id of the Email Template that is used when User Actions expired automatically (end)."
    includeEmailInEventJSON: Boolean

    "A mapping of localized names for this User Action. The key is the Locale and the value is the name of the User Action for that language."
    localizedNames: [LocalizedStringInput!]

    "The Id of the Email Template that is used when User Actions are modified."
    modifyEmailTemplateId: UUID

    "The name of this User Action."
    name: String!

    "The list of User Action Options."
    options: [UserActionOptionInput]

    "Defaults to false. Whether or not this User Action will prevent user login. When this value is set to true the action must also be marked as a time based action. See temporal."
    preventLogin: Boolean

    "Defaults to false. Whether or not FusionAuth will send events to any registered Webhooks when this User Action expires."
    sendEndEvent : Boolean

    "The Id of the Email Template that is used when User Actions are started (created)."
    startEmailTemplateId: UUID

    """Defaults to false. Whether or not this User Action is time-based (temporal). Time based actions are temporary and once expired the action will no longer be considered active and will not affect the user.

An action that prevents login must be time based.

Time based actions can still be applied to a user for an indefinite amount of time. A time based action is one that may be canceled or modified. A non time-based action may not be modified or canceled.

An example of a non time-based action would be a reward, such as sending a user a coupon. This action cannot be canceled, or modified. When a non time-based action is taken, it is immediately complete and will show up in the user action history.
"""
    temporal: Boolean

    "Defaults to false. Whether or not email is enabled for this User Action. If this is true, a checkbox will appear in the FusionAuth UI for this User Action that allows admins to specify that they want to email the User."
    userEmailingEnabled: Boolean
    "Defaults to false. Whether or not user notifications are enabled for this User Action. If this is true, a checkbox will appear in the FusionAuth UI for this User Action that allows admins to specify that they want to \"notify users\". What is does is send an additional flag named notifyUser in the event JSON that is sent to any registered Webhooks."
    userNotificationsEnabled: Boolean
}


type UserActionOption {
    "A mapping of localized names for this User Action Option. The key is the Locale and the value is the name of the User Action Option for that language."
    localizedNames: [LocalizedString!]

    "The name of this User Action Option."
    name: String
}

type UserAction {
    "The Id of the Email Template that is used when User Actions are canceled."
    cancelEmailTemplateId : UUID
    cancelEmailTemplate: EmailTemplate
    "The Id of the Email Template that is used when User Actions expired automatically (end)."
    endEmailTemplateId: UUID
    endEmailTemplate: EmailTemplate

    "The Id of the Email Template that is used when User Actions expired automatically (end)."
    includeEmailInEventJSON: Boolean

    "A mapping of localized names for this User Action. The key is the Locale and the value is the name of the User Action for that language."
    localizedNames: [LocalizedString!]

    "The Id of the Email Template that is used when User Actions are modified."
    modifyEmailTemplateId: UUID
    modifyEmailTemplate: EmailTemplate

    "The name of this User Action."
    name: String!

    "The list of User Action Options."
    options: [UserActionOption]

    "Defaults to false. Whether or not this User Action will prevent user login. When this value is set to true the action must also be marked as a time based action. See temporal."
    preventLogin: Boolean

    "Defaults to false. Whether or not FusionAuth will send events to any registered Webhooks when this User Action expires."
    sendEndEvent : Boolean

    "The Id of the Email Template that is used when User Actions are started (created)."
    startEmailTemplateId: UUID
    startEmailTemplate: EmailTemplate

    """Defaults to false. Whether or not this User Action is time-based (temporal). Time based actions are temporary and once expired the action will no longer be considered active and will not affect the user.

    An action that prevents login must be time based.

    Time based actions can still be applied to a user for an indefinite amount of time. A time based action is one that may be canceled or modified. A non time-based action may not be modified or canceled.

    An example of a non time-based action would be a reward, such as sending a user a coupon. This action cannot be canceled, or modified. When a non time-based action is taken, it is immediately complete and will show up in the user action history.
    """
    temporal: Boolean

    "Defaults to false. Whether or not email is enabled for this User Action. If this is true, a checkbox will appear in the FusionAuth UI for this User Action that allows admins to specify that they want to email the User."
    userEmailingEnabled: Boolean
    "Defaults to false. Whether or not user notifications are enabled for this User Action. If this is true, a checkbox will appear in the FusionAuth UI for this User Action that allows admins to specify that they want to \"notify users\". What is does is send an additional flag named notifyUser in the event JSON that is sent to any registered Webhooks."
    userNotificationsEnabled: Boolean
}

extend type Mutation {
    createUserAction(
        "The Id to use for the new User Action. If not specified a secure random UUID will be generated"
        userActionId: UUID,
        input: UserActionInput!
    ) : UserAction

    updateUserAction(
        "The Id of the User Action to update"
        userActionId: UUID!,
        input: UserActionInput!
    ) : UserAction

    deleteUserAction(
        "The Id of the User Action to delete"
        userActionId: UUID!,
        hardDelete: Boolean
    ) : Boolean

    reactivateUserAction(
        "The Id of the User Action to reactivate."
        userActionId: UUID!) : UserAction
}

"A `UserAction` edge in the connection."
type UserActionsEdge {
    "A cursor for use in pagination."
    cursor: Cursor
    "The `UserAction` at the end of the edge."
    node: UserAction
}

"A connection to a list of `UserAction` values."
type UserActionsConnection {
    "A list of edges which contains the `UserAction` and cursor to aid in pagination."
    edges: [UserActionsEdge!]!
    "A list of `UserAction` objects."
    nodes: [UserAction]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "The count of *all* `UserAction` you could get from the connection."
    totalCount: Int!
}

extend type Query {
    userAction(userActionId: UUID!) : UserAction

    "Reads and enables pagination through a set of `UserAction`."
    userActions(
        "Read all values in the set after (below) this cursor."
        after: Cursor,
        "Read all values in the set before (above) this cursor."
        before: Cursor,
        "Only read the first `n` values of the set."
        first: Int,
        "Only read the last `n` values of the set."
        last: Int,
        "Skip the first `n` values from our `after` cursor, an alternative to cursor based pagination. May not be used with `last`."
        offset: Int,
    ): UserActionsConnection
}
